##### 2023.02.22

###### 1、块元素和行内元素的区别？

区别：

（1）块级元素独自占据一行，垂直方向排列，行内元素会在一条直线上排列，都是在同一行上的，水平方向排列；

（2）块级元素中可以包含行内元素和块级元素；

（3）行内元素与块级元素属性不同；



###### 2、axios如何进行get、post封装？

axios：是一个基于promise的网络请求库，可以用于浏览器和node..js

（1）创建axios基础配置

```js
// 创建一个request.js文件
import axios from 'axios'
export function request() {
    // 1、创建axios实例
    const instance  = axios.create({
        // 设置基础的url配置项，这样接口处的url前面就不用写url:'http://127.0.0.1:8000/api/home',直接写成url:'api/home',就可以
        baseURL: 'http://127.0.0.1:8000/',
        // 设置请求超时时间
        timeout: 5000
    })
    // 2、axios的拦截器
    // 2.1 请求拦截的作用
    instance.interceptors.request.use(config => {
        return config
    }, err => {
        console.log('请求拦截err:' + err);
    })
    // 2.2 响应拦截
    instance.interceptors.response.use(res => {
        return res.data
    }, err => {
        console.log('响应拦截err:' + err);
    })
    // 3、发送真正的网络请求
    return instance(config)
}
```

（2）封装网络请求

```js
// 创建一个network.js，内容如下：
// 导入封装好的axios
import {request} from './request' // 注意requeat.js相对路径问题
// 1、get请求--获取首页的多个数据
export function getHomeMultiData() {
    return request({
        url: '/api/home',
        method: 'get',
        // 可带参数也可不带参数
    })
}
// 2.1 post请求--传输json数据时，获取多个数据
export function getTVShowMultidata() {
    return request({
        url: '/api/TVShow',
        headers: {
            'Content-Type': 'application/json'
        },
        method: 'post',
        data: {
            userName: 'zs',
            password: '123456'
        }
    })
}
// 2.2 post请求---传输文件流，表单Form Data数据时
export function getMovieMultiData() {
    return request({
        url: '/api/Movie',
        headers: {
            'Content-Type': 'multipart/form-data';
        },
        method: 'post',
        data: {
            userName: 'zs',
            password: '123456'
        }
    })
}
// 3、在vue中使用
// 在script标签中按需引入network.js中需要使用的地方
import {getMovieMultiData} from "/" // 导入js,路径根据自己存放的文件位置
// 在方法中按照promise的格式调用函数
created() {
    // 在方法中调用函数
    getMovieMultiData().then(res => {
        // 此处res为返回的数据，将返回的数据进行数据处理显示
        this.banners = res.homedata.slice(0, 5);
        this.newsetData = res.homedata.slice(5, 12);
    }).catch(err => {
        console.log(err)
    })
}
```

（3）没有封装的用法

```js
// 首先直接在项目中下载axios
npm install axios -s // 会将axios下载到package.json中的"dependencies"模块中
// 因为没有封装所以需要在单个vue组件中编写js的地方进行引用axios
<script>
import axios from 'axios'
</script>
// 然后在生命周期函数中进行调用数据
export default {
    created() {
        // get请求
        axios.get("url", {
            params: { // 为get请求传递的参数 但是一般get请求是无参数的，params是固定的
                password: "123456",
                userName: 'zs'
            },
        }).then(function (response) {
            console.log(response, 666)
        }).catch(function err) {
            console.log(err, 111)
        }
    }
}

// post请求
axios.post('url', {
    // 此处为参数
    firstName：'ls',
    lastName: 'alei'
}).then(function (response) {
    console.log(response)
}).catch(function (error) {
    console.log(error)
})
```

（4）封装之后的用法

```js
// 首先一个目录utils，在该目录下创建request.js在里面编写
import axios from 'axios'
export function request((config) {
    // 1、创建axios的实例
    const instance = axios.create({
        // 设置基础的url配置项，这样接口处的url前面就不用写了
        baseUrl：'http://192.168.0.112:9518/',
        // 设置请求超时时间
        timeout: 5000
    })
    // 2、axios的拦截器
    // 2.1请求拦截的作用
    instance.interceptors.response.use(res => {
        return res.data
    }, err => {
        console.log('响应拦截err：' + err)
    })
    // 3.发送真正的网络请求
    return instance(config)
})

// 然后在目录下创建api在此处创建index.js在此处引用上方创建的axios实例
import {request} from '../utils/request'
// get请求
export function denglu() {
    return request({
        url: 'login',
        method: 'get',
        params: { // get一般不传递参数
            password: '123456',
            userName: 'zs'
        }
    })
}
export function denglu() {
    return request({
        url: 'login',
        method: 'post',
        data: { // 此处为传递的参数
            password: '123456',
            userName: 'zs'
        }
    })
}
// 之后在vue组件方法中进行应用
```



###### 3、基本数据类型、复杂数据类型有哪些？

基本数据类型：字符串（String）、数字（Number）、布尔（Boolean）、空（Null）、未定义（undefined）；

复杂数据类型：对象（Object）、数组（Array）、函数（Function）、Symbol（ES6新引入的原始数据类型，表示独一无二的值）、Map、Set；【还有两个特殊的对象：正则（RegExp）和日期（Date）】

Tip：可以用typeof操作符来检测类型



###### 4、元素垂直居中的方法？

（1）利用line-height属性、元素行高属性；

（2）利用元素上下内边距（padding属性）；

（3）利用flex布局；

（4）使用position：fixed定位方式实现在浏览器窗口居中对齐方式；

（5）使用相对定位与绝对定位实现子盒子在父盒子上居中对齐；



###### **5、路由守卫包含哪些？写出具体的名称及作用。**

分类：全局的、单个路由独享的、组件级的；

每个守卫方法接收两个参数：

to：即将要进入的目标

from：当前导航正要离开的路由

全局的有三个守卫：

（1）beforeEach()：全局前置守卫，当一个导航被触发时，按照创建顺序调用；

（2）beforeResolve()：全局解析守卫，在每次导航都会被触发，但确保在导航被确认之前，同时在所有组件内守卫的异步路由组件被解析之后，解析守卫才被正确调用（是获取数据或执行任何其他操作的理想位置）；

（3）afterEach()：全局后置钩子，不会接受next函数也不会改变导航本身，对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用；

组件内的守卫：

（1）beforeRouteEach()：在渲染该组件对应的路由被验证前调用，不能获取组件实例`this`；

（2）beforeRouteUpdata()：在当前路由改变，但是组件被复用时调用可以访问组件实例；

（3）beforeRouteLeave()：在导航离开渲染该组件的对应路由时调用；

单个路由独享的守卫：

beforeEnter：只在进入路由时触发（从一个不同的路由导航时，才会被触发）



###### 6、computed和watch的区别？

（1）computed是计算属性；watch是监听，监听data中的数据变化；

（2）computed支持缓存，当属性值发生变化时，则会重新计算，反之，则使用缓存中的属性值，watch不支持缓存，当对应属性发生变化时，会响应执行；

（3）computed不支持异步，有异步操作时无法监听数据变化；watch支持异步操作；

（4）computed第一次加载时就监听，watch默认第一次加载不监听；

（5）computed中的函数必须调用return，而watch不是

（6）computed：一个属性受到多个属性影响；watch：一个数据影响多条数据；



###### 7、React的setState是同步的还是异步的？

既是同步的也是异步的；



###### 8、watch能监听computed的属性吗？

可以监听；



###### 9、map 和 v-for 中 key 的作用？

v-for中的key：主要作为Vue的虚拟DOM算法提示，在比较新旧节点列表时用于识别vnode;如果没有key的情况下，使用一种最小化元素移动算法，尽可能复用/更新相同类型的元素；如果传了key，则将根据key的变化顺序来重新排列元素，并移除/销毁key已经不存在的元素；

map中的key：（主要用于react列表遍历）key值可以追踪列表中哪些元素被修改、添加或移除的辅助标识；



###### 10、Vue中的data，为什么是个函数，而不是对象？

防止存在引用对象的问题；组件是用来复用的，并且JS里对象是引用关系，如果组件中data是一个对象，则这样作用域没有隔离，子组件中的data属性值会相互影响；如果组件中data选项是一个函数，那么每个实例可以维护一份被返回对象的独立拷贝，组件之间的data属性值不会相互影响。



##### 2023.02.23

###### 1、补充还有啥判断类型的方法？

（1）typeof判断基本数据类型；

（2）instanceof：用来判断A是否为B的实例，用这个来判断数组；表达式：A instanceof B，返回的是布尔值；

（3）constructor属性：JS在函数的原型上定义了constructor，当函数被当作构造函数用来创建对象时，创建的新对象就被标记为函数类型；但此属性是不稳定的，主要体现在自定义对象上，如果重写了原型后，原来的constructor会丢失，该属性默认为object；

（4）Object.prototype.toString()：一般用于检测对象；



###### 2、Map和Set的区别？

区别：

（1）Set所得的元素只有key无value，value就是key；map中的所有元素都是key+value存在的；

（2）不能通过迭代器来改变Set的值，因为Set的值就是键；map

的值都是可以修改的；

（3）Set的值是唯一的可以做数组去重的，Map可以做数据存储；

（4）Map可以通过get方法获取值，而Set不可以；



###### 3、列举块元素和行内元素，行内元素转变为块级元素的方式？

块级元素：<address>、<article>、<aside>、<blockquote>、<dd>、<div>、<dl>、<fieldset>、<figcaption>、<figure>、<footer>、<form>、<h1-h6>、<header>、<hgroup>、<hr>、<ol>、<p>、<pre>、<section>、<table>、<ul>；

行内元素：<b>、<big>、<i>、<small>、<tt>、<abbr>、<acronym>、<cite>、<dfn>、<em>、<kdb>、<strong>、<samp>、<var>、<a>、<bdo>、<img>、<map>、<object>、<q>、<script>、<span>、<sub>、<sup>、<button>、<input>、<label>、<select>、<textarea>；



###### 4、什么是盒模型？

本质为一个盒子，把周围的HTML元素包装起来，包括：边距、边框、填充和实际内容；



###### 5、var val = ’hello‘;console.log('value is' + (val === 'hello') ?  'somethig'  :  'nothing' );  该代码输出什么，为什么会这样子输出？

会输出something，考虑到运算符的优先级，该输出语句的运算符有+、===、（）、?:  ,语句先执行===，判断val === ‘hello’后再执行 + 拼接，最后执行三元表达式；



###### 6、display：none和visibility：hidden的区别？

display：none：是销毁元素，该元素节点已不存在；

visibility：hidden：只是把设置了该属性的元素隐藏起来；



###### 7、如何解决页面内容加载缓慢的问题？

（1）使用分页加载；

（2）去掉不必要插件；

（3）优化图像；

（4）利用浏览器缓存；



###### 8、HTML5的新特性

（1）canvas元素：用于绘画；

（2）video和audio：用于媒介回放；

（3）新增内容元素：article、footer、header、nav、section；

（4）表单控件：calendar、date、time、email、url、search；

（5）本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失；

（6）sessionStorage的数据在浏览器关闭后自动删除；

（7）新技术webworker、websocket、Geolocation；



###### 9、什么是闭包？

闭包就是能够读取其他函数内部变量的函数；



###### 10、什么是原型、什么是原型链，二者的有什么联系？

原型：每个对象都会在其内部的初始化一个属性；

原型链：如果在原型上没有找到该属性，就会继续找；

联系：原型链可以说是原型的祖先



##### 2023.02.24

###### 1、页面渲染过程

（1）HTML解释器将字节流解释成DOM树；

（2）CSS解释器把CSS字符串解释后生成style rules；

（3）生成RenderObject树；

（4）绘制Render树；

（5）渲染成合成（composite），显示在屏幕上；



###### 2、localStorage和sessionStorage的区别？

共同点：都是保存在浏览器端、同源的；

不同点：

（1）作用域不同：

sessionStorage在不同的浏览器窗口中共享，即使是同一个页面；localStorage在所有同源窗口中都是共享的，即只要浏览器不关闭，数据依然存在；

（2）存储限制不同：

sessionStorage：仅在当前浏览器窗口关闭前有效，而localStorage始终有效，窗口或浏览器关闭也一直保存，即使窗口关闭或浏览器关闭；



###### 3、JS的选择器有哪些？

属性选择器、ID选择器、标签选择器、类选择器；



###### 4、图片预加载和懒加载的方法？

预加载：先将图片提前加载到缓存，用户一打开就能快速呈现图片；

（1）CSS的background元素会自动预加载；

（2）JS则常用new Image()实现；

懒加载：在渲染页面时，先将图片用一张默认图片代替，当图片到达浏览器可视区域时，才显示真实的图片；

（1）使用SsetTimeOut或setInterVal定时器进行延迟加载；

（2）条件加载，符合条件或触发事件后再进行异步下载；

（3）通过滚动条监听用户距图片的距离，快要到达之前进行加载；



###### 5、数组转字符串的方法？

（1）toString();

（2）toLocaleString();

（3）join();



###### 6、如何把类数组转换成数组？

（1）Array.prototype.slice.call（arrayLike）；

（2）通过call调用数组的splice方法来实现转换；

（3）通过apply调用数组的concat方法来实现转换；

（4）Array.from();



###### 7、for...in和for...of的区别

对数组进行遍历时，for...in获取到的是每次遍历项的索引值，而for...of每次遍历获取到的是每个遍历项的value值；

遍历对象时，每一次遍历得到的是对象的key值，而使用for...of遍历时则会报错，不能用for...of来遍历对象。获取到的不是每一个遍历项的value值；



###### 8、数组去重的方法；

（1）filter()和indexOf();

（2）reduce()和includes();

（3）Set;



###### 9、ES6常见语法

（1）解构赋值：针对数组或者对象进行模式匹配，然后对其中的变量进行赋值；

（2）子串识别方法：includes()、startWith()、endsWith();

（3）模板字符串 ``：除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式；

（4）拓展运算符 ... ：用于取出参数对象所有可遍历属性然后拷贝到当前对象；

（5）模块export和import：export可以出现在模块的任何位置，但必须在模块顶层；import命令会提升到整个模块的头部，首先执行；

（6）对象的Object.assign()方法：将源对象的所有可枚举属性赋值到目标对象中；



###### 10、普通函数和箭头函数的区别?

（1）箭头函数更加简洁；

（2）箭头函数没有自己的this；

（3）箭头函数继承来的this指向永远不会改变；

（4）call()、apply()、bind()等方法不能改变箭头函数的this指向；

（5）箭头函数不能作为构造函数使用；

（6）箭头函数没有自己的arguments；

（7）箭头函数没有prototype；



##### 2023.02.27

###### 1、

```js
var obj = {}

if(obj) {

 console.log('哈哈哈')

}
```

这段代码运行会输出哈哈哈嘛，如果会输出，为什么，如果不输出，那又是为什么？

这段代码运行会输出哈哈哈，因为obj虽然为空对象，但是在栈内存中存的是该空对象的地址，所以该条件判断并不为false；



###### 2、谈谈你对this对象的理解；

this在开发中的作用（代表当前调用对象）：

（1）全局 ---> window

（2）对象调用  ----->   调用的对象



###### 3、null和undefined的区别？

（1）undefined通常只有在一个变量声明单位初始化的时候，默认值是undefined才会用到；

（2）不推荐直接给一个变量赋值为undefined;

（3）null值非常有用，但此对象不确定时，可以先赋值为null；



###### 4、介绍js有哪些内置对象？

数字类型Number、数学对象Math、字符串类型String、数组Array、Date类型；



###### 5、拼接字符串的方法；

（1）+；

（2）concat()方法；



###### 6、讲下你做轮播图的思路，无缝轮播该怎么实现？

（待深究）



###### 7、js对数组有哪些操作方法？

（1）添加：push()[在尾部添加]、unshift()【在头部添加】；

（2）删除：pop()[在尾部删除]、shift()【在头部删除】；

（3）中间添加或删除元素：splice()；



###### 8、什么是 DOM 和 BOM？

（待深究）



###### 9、改变this指向的方法有哪些？

（1）重新改变调用对象



###### 10、说几条写 JavaScript 的基本规范？

（1）代码行采用两个空格缩进；

（2）每个语句完成都写上分号；

（3）一行代码不要超过120个字符；



##### 2023.02.28

###### 1、写一下你常见的http状态码以及其代表的含义；

100：continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息；

200：ok      正常返回信息

301：Moved Permanently  请求的网页已永久移动到新位置

302：Found  临时性重定向

303：See Other  临时性重定向，且总是使用GET请求新的URI

304：Not Modified  自从上次请求后，请求的网页未修改过

400：Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求；

401：Unauthorized  请求未授权

403：Forbidden  禁止访问

404：Not Found：找不到如何与URI相匹配的资源

500：Internal Server Error  最常见的服务器错误

503：Service Unavailable  服务器端暂时无法处理请求



###### 2、CSS优先级算法如何计算？

就近原则，载入样式以最后载入的定位为准

优先级为：！important > id > class > tag



###### 3、什么是立即执行函数？

立即执行函数也称为立即调用的函数表达式。类似于函数声明，但由于包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。



###### 4、document.write()和innerHTML的区别？

document.write()只能重绘整个页面；

innerHTML可以 重绘页面的一部分





###### 5、["1","2","3"].map(parseInt)答案是什么？

[1, NaN, NaN]；因为parseInt需要两个参数（val，radix），radix表示解析时用的基数，map传了3个（element，index，array），对应的radix不合法导致解析失败；



###### 6、什么是事件代理和事件委托？

事件代理（事件委托）：利用事件冒泡，可以只使用一个事件处理程序来管理一种类型的事件；



###### 7、link和import区别？

（1）link属于XHTML标签，除了加载css外，还能用于定义RSS，定义rel连接属性等作用，而import是css提供的，只能用于加载CSS；

（2）页面被加载时，link会同时被加载，而import引用的css等到页面被加载完再加载；

（3）import只能在IE5以上才能被识别，而link是XHTML标签，无兼容问题；



###### 8、什么是作用域？

一段代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域；



###### 9、http 和 https 的区别？

http（超文本传输协议）: 是一种用于分布式、协作式和超媒体信息系统的应用层协议。是一种发布和接收HTML页面的方法，被用于web浏览器和网站服务器之间传递信息。http默认工作在TCP协议80端口，以明文方式发送内容，用户访问网站http://开头的都是标准HTTP服务。HTTP协议以明文方式发送内容，不提供任何方式的数据检，如果攻击者截取了web浏览器和网站服务器之间的传输明文，就可以直接读懂其中的信息，因此，http协议不适合传输一些敏感信息；

https(超文本传输安全协议)：是一种透过计算机网络进行安全通信的传输协议。https经由http进行通信，但利用SSL/TLS来加密数据包，https开发的主要目的，是提供对网站服务器的身份认证，保护交换数据隐私与完整性；



###### 10、网络分层（OSI）里七层模型？

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层；



##### 2023.03.01

###### 1、简述一下你对HTML语义化的理解？

html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有CSS情况下也以一种文档格式显示，且易于阅读；



###### 2、CSS3新增伪类有哪些？

:first-of-type  选择属于其父元素首个元素的每个元素

:last-of-type  选择属于其父亲的最后元素的每个元素

:only-of-type  选择属于其父元素唯一的元素的每个元素

:only-child  选择属于其父元素的唯一子元素的每个元素

:nth-child(2)  选择属于其父元素的第二个子元素的每个元素

:after  在元素之前添加内容，也可以用来做清除浮动

:before  在元素之后添加内容

:disabled  控制表单控件的禁用状态

:checked  单选框或复选框被选中



###### 3、display有哪些值？说一下它们的作用。

block: 像块类型一样显示

none: 此元素不会被显示

inline-block: 像行内元素一样显示，但其内容像块类型元素一样显示

list-item: 像块类型元素一样显示，并添加样式列表标记

table: 此元素会作为块级表格来显示

inherit: 规定应该从父元素继承display属性的值



###### 4、什么是window对象，什么是document对象？

window对象：在浏览器中有两重身份一个是ECMAScript中的Global对象，另一个是浏览器窗口的JS接口；

document对象：是HTMLDocument的实例，表示整个HTML页面；



###### 5、同步和异步的区别？

同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求，等请求完，页面刷新，新内容出现，用户看到新内容，进行下一步操作；

异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求，等请求完，页面不刷新，新内容也会出现，用户看到新内容；



###### 6、什么是同源策略？

是一种约定，是浏览器最核心最基本的安全功能，同源即域名、协议、端口相同；



###### 7、如何解决跨域？

（待深究）



###### 8、let和const 的区别是什么?

let声明的变量可以改变，值和类型都可以改变；

cost声明的常量不可以改变，一旦声明，就必须立即初始化，不能以后再赋值；



###### 9、VUE子传父组件传递数据，父传子的传递事件分别是哪个？

父组件向子组件用props:['value']接收；

子传父通过$emit事件传递；



###### 10、v-show和v-if指令的共同点和不同点？

共同点：都能控制元素的显示和隐藏；

不同点：实现的方法不同，v-show本质是通过控制CSS中的display设置为none,控制隐藏，只会编译一次；v-if是动态地向DOM树内添加或者删除DOM元素，若初始值为false，就不会编译了。而且v-if不停地销毁和创建比较消耗性能；



##### 2023.03.02

###### 1、什么是模块化？

将一些独立的功能封装成单独的块，并组合在一起；块内部的数据是私有的，想要向外暴露接口来通讯；



###### 2、v-if与v-for谁的优先级更高？

v-if的优先级更高



###### 3、vue组件通信方式有哪些？

（1）父组件向子组件传递数据用props

（2）子组件向父组件传递数据（$emit）

（3）兄弟组件通信

（4）ref/$refs

（5）eventBus事件总线（$emit/$on）

（6）依赖注入（provide/inject）

（7）$parent/$children

（8）$root

（9）vuex

（10）$attrs/listeners



###### 4、http请求方法有哪些？

get、post、put、delete、head、trace



###### 5、route和router的区别是什么？

router为VueRouter的实例，相当于一个全局的路由器对象，里面包含很多属性和子对象；

route代表当前路由信息对象；



###### 6、addEventListener的作用是什么？

用于注册事件监听器的方法；



###### 7、如何判断一个对象是空对象？

（1）for...in遍历属性:if是空对象返回false，否则返回true；

（2）Object.keys()：该方法会返回一个有给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用for...in循环遍历该对象时返回的顺序一致；



###### 8、什么是标识符？

用于标识某个实体的符号；



###### 9、==和===的区别？

==：比较两个值是否相等，===比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符直接返回false，而==会将它们转换成同一个类型，再用===来进行比较；



###### 10、函数声明与函数表达式的区别？

用函数声明创建的函数定义之前就进行调用；而函数表达式创建的函数不能再该函数被赋值之前进行调用；



##### 2023.03.03

###### 1、比较typeof和instanceof;

（1）typeof会返回一个运算数的基本类型，instanceof返回的是布尔值；

（2）instanceof可以准确判断引用数据类型，但不能正确判断原始数据类型；

（3typeof可以判断原始数据类型（null除外），但无法判断引用数据类型（function除外）



###### 2、vue的watch有什么属性？

immediate属性：如果需要在最初绑定值的时候也执行函数，则需要该属性；

deep属性：当需要监听一个对象改变时，普通的watch方法无法监听到对象内部属性的改变，此时需要deep属性对对象进行进行深度监听；



###### 3、CSS有几种布局方式？

浮动布局、流布局、弹性布局、混合布局、绝对定位布局、固定布局；



###### 4、get和post有什么区别？

GET方式的请求，浏览器会把http header和data一并发出去，服务器响应200（返回数据）；POST请求，浏览器再发送data，服务器响应200 ok（返回数据）；



###### 5、Vue如何获取DOM？

（1）通过ref来获取DOM元素；

（2）通过ID来获取

（3）通过标签名来获取

（4）通过类名来获取

（5）通过name属性来获取

（6）通过CSS选择器



###### 6、<img>的title和alt有什么区别？

alt属性：用于替换说明，对于图像和图像热点是必须的；只能在img、area和input元素中；保证那些文字确实为那些看不到图像的人提供了说明信息，并且在上下文中有意义。对于那些装饰性的图片可以用空值；值的长度必须少于100个英文字符或用户必须保证替换文字尽可能地短；

title属性：为设置该属性的元素提供建议性的信息，即提供非本质的额外信息，大部分的可视化浏览器在鼠标悬浮在特定元素上时显示title文字为为提示信息，可以用在除了base、basefont、head、html、meta、param、script、和title之外的所有标签，但非必须；可以为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。一个潜在的应用是为图像提供额外的说明信息；title属性的值可以比alt属性值设置得更长；



###### 7、什么是重绘，什么是重排？

重绘：当一个元素的外观发生改变，但没有改变布局，浏览器重新吧元素外观绘制出来的过程；

重排：当渲染树的一部分必须更新且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树；



###### 8、setInterval和setTimeout的区别？

setInterval()：可以执行多次，表示间隔一定时间反复执行；

setTimeout()：定时程序，不会反复执行，只执行一次；

相同点：用于创建定时器

不同点：

（1）清除定时器的方法不同；

（2）setTimeout()：在指定的毫秒数后就会执行，而setInterval()在每间隔指定的毫秒数执行；



###### 9、px,em,rem,%在CSS具体代表什么长度？

px：绝对长度

em,rem,%：相对长度



###### 10、路由跳转的方式？

（1）router-link=to“跳转路径”

（2）命名式路由跳转

（3）编程式路由跳转



##### 2023.03.06

###### 1、href和src的区别？

href：是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的连接，用于超链接；

src：是指向外部资源的位置，指向的是内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中；

区别：

（1）请求资源类型不同：href指向网络资源所在的位置，建立和当前元素（锚点）或当前文档（链接）之间的联系。在请求src资源时会将其指向的资源下载并应用到文档中，比如js脚本，img图片；

（2）作用结果不同：href用于在当前文档和引用资源之间确立联系；src用于替换当前内容；

（3）浏览器解析不同：当浏览器解析到src，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此；



###### 2、flex布局常用属性

flex-direction：用于决定主轴的方向（即项目的排列方向，值有row、row-reverse、column、column-reverse）

flex-wrap：用于如果一条轴线排不下，如何换行（nowrap：不换行、wrap：换行（第一行在上方）、wrap-reverse：换行，第一行在下方）

flex-flow：是flex-direction属性和flex-wrap属性的简写形式；

justify-content：定义了项目在主轴上的对齐方式(flex-start：左对齐|flex-end：右对齐|center：居中|space-between：两端对齐，项目之间的间隔相等|space-around：每个项目的两侧的间隔相等)

align-items：定义项目在交叉轴上如何对齐（flex-start：交叉轴的起点对齐|flex-end：交叉轴的终点对齐|center：交叉轴的中点对齐|baseline：项目的第一行文字的基线对齐|stretch：如果项目未设置高度或设为auto，将占满整个容器的高度）

align-content：定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用（flex-start：与交叉轴的起点对齐|flex-end：与交叉轴的终点对齐|center：与交叉轴的中点对齐|space-between：与交叉轴两端对齐|space-around：每根轴线的间隔都相等。|stretch：轴线占满整个交叉轴）



###### 3、var、let、const的区别？

var：用于声明变量，存在变量提升；

let：声明的变量只在let命令所在的代码块内有用；

const：声明一个只读的常量，一旦声明，常量的值就不能改变；



###### 4、宏任务和微任务指的是哪些？

宏任务：整体代码script、setTimeout、setInterval、setImmediate、I/O操作、UI render、异步ajax等；

微任务：Promise、async/await、process.nextTick、Object.observe、MutationObserver



###### 5、什么是虚拟DOM？

用原生的JS对象去描述一个DOM节点，实际上它只是对真实DOM的一层抽象；



###### 6、class和style如何动态绑定？

class、style可以通过对象语法和数组语法进行绑定；



###### 7、eval是做什么的？

把对应的字符串解析成js代码并运行；应避免使用eval，不安全，非常耗性能（两次，一次解析成js语句，一次执行）



###### 8、箭头函数有哪些特点？

（1）不需要function关键字来创建函数；

（2）省略return关键字

（3）改变this指向



###### 9、JSON的了解

JSON是一种轻量级的数据交换格式。是基于一个JS的子集，格式简单，易于读写，占用宽带少；



###### 10、解释一下JS的同源策略

概念：同源策略是客户端脚本（目的是防止某个文档或脚本从多个不同源装载）

同源策略指的是：协议、域名、端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一个来源的窗口和文档属性；



##### 2023.03.07

###### 1、vuex有哪些模块？

State：用一个对象包含了全部的应用层级状态；

Getter：store的计算属性；

Mutation：更改Vuex的store中的状态唯一方法是提交mutation，类似于事件，每个mutation都有一个字符串的事件类型和一个回调函数，该回调函数是实际进行状态更改的地方，且会接受state作为第一个参数；

Action：类似于mutation，不同在于Action提交的是mutation，而不是直接更改状态，可以包含任意异步操作；

Module：将store分割成模块module；



###### 2、为什么在v-for循环时，不建议使用index作为key？

key的作用主要是为了高效的更新虚拟DOM，如果使用index来作为key，则index前的元素会直接复用，index后的元素会重新渲染，降低了复用效率；



###### 3、什么是DNS？

DNS是域名系统的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务；域名是有圆点分开一串单词或缩写组成的，每一个域名都对应一个唯一的IP地址，在Internet上域名与IP地址之间是对应的；



###### 4、new关键字都做了什么事情？

（1）创建了一个空对象，且this变量引用该对象，同时还继承了该函数的原型；

（2）属性和方法被加入到this引用的对象中；

（3）新创建的对象由this所引用，且最后隐式的返回this；



###### 5、什么是XSS攻击与CSRF攻击？

XSS攻击：一种代码注入攻击，攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息，进而危害数据安全；

CSRF攻击：是一种挟持用户在已登录的web应用程序上执行非本意的操作攻击方法，利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户被攻击的网站执行某项操作的目的；



###### 6、严格模式的限制有哪些？

严格模式会深度监测状态树检测不合规的状态变更，在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误，这样能保证所有的状态变更都能被调试工具追踪到；



###### 7、内存泄漏是指什么？

内存泄漏是因为疏忽或错误造成程序未能释放已经不再使用的内存的情况，即内存在程序运行中动态申请的内存空间由于某种原因程序为释放或无法释放；



###### 8、script 引入方式?

（1）直接在HTML页面使用<script>标签引入，可以写在head中，也可以写在body末尾；

（2）在html中使用script的src属性引入外部文件；

（3）事件定义，直接在组件后面的事件写JS代码；

（4）在一个JS文件调用另一个JS文件；



###### 9、Keep-alive的作用是什么？

用来缓存组件，避免多次加载相应的组件，从而减少性能消耗，从一个页面链接到其他页面后回到第一个页面不需要重新执行第一个页面的代码，只会从缓存中加载之前已经缓存的页面，减少加载时间以及性能消耗，提高用户体验性；



###### 10、说出几种vue当中的指令和它的用法

v-if、v-show：用于条件地渲染一块内容；

v-for：基于一个数组渲染一个列表；

v-on：监听事件，并在事件触发时执行对应的JS；

v-bind：将值绑定到当前组件实例上的动态数据；

v-model：可以在组件上实现双向绑定；



##### 2023.03.08

###### 1、$nextTick的实现原理是什么？

（1）异步说明：

​		所有同步任务都在主线程上执行，形成一个执行栈；

​		主线程外，还存在一个“任务队列”，只要异步任务有了运行结果，就在“任务队列”中放置一个条件；

​		一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

​		主线程不断重复上面第三步；

（2）事件循环说明：同步代码执行  -> 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环1] -> 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环2]...



###### 2、Vue中的$set是如何实现添加数据并进行响应化的？

首先判断是数组还是对象

数组：使用splice变异方法触发数组的响应化处理；

对象：使用defineReactive进行响应化处理



###### 3、虚拟DOM的优缺点有哪些？

优点：

（1）保证性能下限：框架虚拟DOM需要适配任何上层API可能产生的操作，它的一些DOM操作的实现不许是普适的，所以它的性能并不是最优的；但比起粗暴的DOM操作性能要好很多，因此框架的虚拟DOM至少可以保证在不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；

（2）无需手动操作DOM：我们不再需要手动去操作DOM，只需要写好View-Model的代码逻辑，框架就会根据虚拟DOM和数据双向绑定，帮我们以预期的方式更新视图，极大提高我们的开发效率；

（3）跨平台：虚拟DOM本质上是JS对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便的跨平台操作；

缺点：无法进行极致优化，虽然虚拟DOM+合理的优化，足以应对绝大多数应用的性能需求，但在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化，首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢；



###### 4、常用的git命令有哪些？

拉取项目：git clone + 项目地址

拉取某个分支：git pull origin 分支名

查看当前分支：git branch

创建并切换分支：git checkout -b 分支名

暂存：git add .

本地提交：git commit -m ’内容‘

远程提交：git push origin 分支名



###### 5、说几个你常用的ES6新特性；

解构赋值、扩展运算符、let和const定义变量和常量、箭头函数；



###### 6、分别简述computed和watch的使用场景；

computed：当一个属性受到多个属性影响时

watch：一个数据影响多个数据



###### 7、v-on可以监听多个方法吗？

可以



###### 8、$nextTick的使用

应用场景：需要在视图更新后，基于新的视图进行操作。

created、mounted



###### 9、第一次页面加载会触发哪几个钩子？

beforeCreate、created、beforeMount、mounted

（1）创建Vue实例，Vue()；

（2）在创建Vue实例的时候，执行了init()初始化，在init过程中先调用了beforeCreate钩子函数；

（3）同时监听data数据，初始化Vue内部事件，进行属性和方法的计算；

（4）模板开始编译，把Vue里面的数据和语法编译成HTML；



###### 10、vue获取数据一般在哪个周期函数？

一般在created、beforeMount、mounted



##### 2023.03.09

###### 1、为什么typeof null是Object？

对象object标志位存储时是000，由于null作为机器代码的0号位置，即全部都为空，所以检测typeof null为object；



###### 2、call、apply、bind的区别是什么？

相同点：都是改变this的指向，传入的第一个参数都是绑定this的指向，在非严格模式中，如果第一个参数是null||undefined，会把全局对象作为this的值，

call和apply的区别：call传入的是参数列表，apply传入的是数组，也可以是类数组；

bind和call、apply区别：bind返回的是一个改变了this指向的函数，便于稍后调用，不像call和apply会立即调用；bind和call很像，传入的也是参数列表，但是可以多次传入，不需要像call，一次传入；

当bind返回的函数使用new作为构造函数时，绑定的this值会失效，this指向实例对象，但传入的参数依然生效（new调用的优先级 > bind调用）



###### 3、为什么JS是单线程的？

（待深究...）



###### 4、exports和module.exports有什么区别？

（1）module.exports才是真正的接口，exports只不过是它的一个辅助工具，最终返回给调用的是module.exports而不是exports,module.exports初始值为一个空对象{}，而exports为指向module.exports的引用；

（2）在require()的时候，返回的是module.exports而不是exports，因此，直接赋值exports常会出现错误，而赋值为module.exports常是解决这一问题的折中方法；

（3）所有的exports收集到的属性和方法，都赋值给了module.exports；



###### 5、HTTP的结构？

由三大部分组成：

（1）起始行：描述请求和响应的基本信息；

（2）头部字段集合：使用keep-alive形式更详细的说明报文；

（3）消息正文：实际传输的数据，可以是文本、图片、视频等；



###### 6、Vue中是如何定义组件的？

全局定义：Vue.component()

局部注册，父组件中使用：Components



###### 7、你常用的组件化技术有哪些？

props、自定义事件$emit、插槽slot、渲染render



###### 8、模块化开发的好处有哪些？

（1）能解决文件之间的依赖关系；

（2）避免命名冲突；

（3）能进行代码的复用；



###### 9、axios如何同时管理多个请求？

axios.all，请求结束后会执行all中的回调函数；



###### 10、const对象的属性可以修改吗？

可以修改；const声明的只是栈区内容不变，基本数据类型保存在栈区中不可改变，引用数据类型在栈区保存的地址不可改变；



##### 2023.03.10

###### 1、UDP和TCP有什么区别？

（1）TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接；

（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大能力交付，即不保证可靠交付；

（3）TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送效率降低；

（4）每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信；

（5）TCP首部开销20字节，UDP的首部开销小，只有8个字节；

（6）TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠的信道；



###### 2、Vue-router跳转和location.href有什么区别？

（1）Vue-router使用pushState进行路由更新，静态跳转，页面不会重新加载；location.href会触发浏览器，页面重新加载一次；

（2）Vue-router使用diff算法，实现按需加载，减少DOM操作；

（3）Vue-router是路由跳转或是同一个页面跳转；location.href是不同页面间跳转；

（4）Vue-router是异步加载this.$nextTick(() => {获取url})；location.href是同步加载；



###### 3、params和query有什么区别？

（1）引入方式不同：query要使用path来引入，params要使用name来引入，接受参数格式类似，引用分别是this.route.query.name和this.route.params.name；

（2）形成路径不同：使用query传参的话，会在浏览器的url栏看到传的参数类似于get请求，使用params传参的话则不会，类似于post请求；

（3）是否受动态路径参数影响：query传递的参数不会受路径参数的影响，会全部展示到路径上，刷新不会丢失query里面的数据；params传递的参数会受路径参数的影响，只会展示含有动态路径参数的部分，刷新会丢失没有设置动态路径参数的params；



###### 4、CSS盒子模型的构成是由哪四个构成？

边距（margin）、边框（border）、填充（padding）以及实际内容（content）



###### 5、如何解决异步问题？

（1）使用回调函数；

（2）使用Promise；

（3）通过async/await；



###### 6、console.log(1 && 2)会输出什么？为什么？

会输出2，因为&&得两个都是成立的才会为true，&&前是1，则式子会继续往后执行，&&后是2，也为true，则输出对应的值2；



###### 7、JS中的&&和||本质是什么？

&&和||的作用只有一个（定义）；

进行布尔值的且和或的运算，当运算到某一个变量就得出最终结果后，就返回那个变量；

a||b：如果a为true,那么b不管是true还是false，都返回true，因此不用判断b了，这个时候刚好判断到b，因此返回a，如果a是false,则要判断b，如果b为true，则返回true，如果b是false，返回false；

a&&b：如果a是false，则b不管是true还是false，都会返回false，因此不用判断b了，这个时候刚好判断到a，因此返回a，如果a是true，则要再判断b，不管b是true还是false，都返回b；



###### 8、JS数组的方法哪些不改变原数组，哪些改变原数组的？

改变原数组的：pop()、push()、reverse()、shift()、unshift()、sort()、splice()；

不改变原数组的：concat()、join()、slice()、JSON.parse(JSON.stringfy())、map()、some()、every()、filter()；



###### 9、直接给一个数组项赋值，Vue能检测到变化吗？

由于JS的限制，Vue不能检测以下数组的变动：

当利用索引直接设置一个数组项时，如：vm.items[indexOfItem] = newValue;

当修改数组长度时，如：vm.items.length = newLength



###### 10、HTTP和HTTPS，为什么HTTPS安全？

HTTP协议通常承载与TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL|TSL），这个时候，就成了HTTPS；由于网络请求需要中间有很多的服务器路由的转发，中间的节点都可以篡改信息，而如果使用HTTPS，密钥在你和终点站才有，HTTPS之所以会比HTTP安全，是因为利用了SSL/TSL协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer传递等，保障了传输过程的安全性；



##### 2023.03.13

###### 1、为什么JS标签不建议写在head元素内？

如果把JS文件都放在<head>里，即意味着必须把所以JS代码都下载、解析和解释完成后，才开始渲染页面。对需要很多JS的页面，这会导致页面渲染明细延迟，在此期间浏览器窗口完全空白。



###### 2、

function test() {

​	message = 'hi';

}

test();

console.log(message)

会有东西输出吗，为什么？

在函数内定义变量时省略var操作符，可以创建一个全局变量；因为调用了test()函数，就会定义这个变量，且在外部函数外部也可以访问到；（这个意思是给window对象添加了一个message属性）



###### 3、JS由什么组成？

ECMAScript + DOM + BOM;



###### 4、从输入url到页面加载发生了什么？

（1）浏览器的地址栏输入url并按下回车键；

（2）浏览器查找当前url是否存在缓存，并比较缓存是否过期；

（3）DNS解析url对应的IP；

（4）根据IP建立TCP连接（三次握手）；

（5）HTTP发起请求；

（6）服务器处理请求，浏览器接收HTTP响应；

（7）关闭TCP连接（四次握手）；

（8）渲染页面，构建DOM树；



###### 5、为什么Vue采用异步渲染？

为了使性能更好，如果不采用异步更新，则每次更新数据都会对当前组件进行重新渲染；



###### 6、为什么Vuex的mutation中不能做异步操作？

Vuex中所有的状态更新唯一途径是mutation，异步操作通过Action来提交mutation实现，这样使得我们可以方便地跟踪每一个状态的变化；每个mutation执行完后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现time-travel了，如果mutation支持异步操作，就无法知道状态是何时更新的，无法很好地进行状态的跟踪，给调试带来困难；



###### 7、什么是EventLoop?

事件循环，是指浏览器或Node环境的一种解决JS单线程运行时不会阻塞一种机制，即实现异步原理；



###### 8、Vue中hash模式和history模式的区别？

（1）hash模式带#号，history模式较优雅；

（2）pushState设置的新的url可以是与当前url同源的任意url；而hash只可以修改#后面的部分，故只可设置与当前同文档的url；

（3）pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串；

（4）pushState设置新的url可以与当前url一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来的不一样才会触发记录添加到栈中；

（5）pushState可额外设置title属性供后续使用；

（6）hash兼容IE8以上，history兼容IE10以上；

（7）history模式需要后端配合将所有访问都指向index.html，否则用户刷新页面，会导致404错误；



###### 9、html元素的id和class有什么区别？

（1）class作用范围比id大：id的值是唯一的，在一个页面只能被调用一次，而class可被调用多次；

（2）id对应的css样式选择符是’#‘，而class对应css样式选择符是’.‘；

（3）id选择符的优先级要高于class选择符；



###### 10、在JQuery中，“$”符号代表什么？

$符号主要用于获得元素对象，通过获取元素，才能使用JQuery方法对齐进行操作；



##### 2023.03.14

###### 1、url格式是怎么样的，它的参数格式是怎么样的？

（1）协议部分：在Internet中可以使用多选协议，如HTTP、FTP等；

（2）域名部分；

（3）端口部分：跟在域名后面的是端口，域名和端口直接使用“：”作为分隔符，端口不是一个url必须的部分，如果省略端口部分，将采用默认端口；

（4）虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分，也不是一个url必须的部分；

（5）文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“？”，则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分，文件名部分也不是一个url必须的部分；

（6）锚部分：从“#”开始到最后，都是锚部分（前端用以作为页面定位），锚部分也不是一个url必须的部分；

（7）参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称摸索部分、查询部分。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符；



###### 2、http请求格式、请求头上有什么字段？

请求行格式：Method [分隔符] Request - URL [分隔符] HTTP- Version CRLF

请求头（客户端 -> 服务器[Requeat Header]）

（1）POST/GET：请求方式、请求地址、请求所使用的的协议和版本；

（2）host：目标主机地址和端口号；

（3）Connection：keep-alive：维护客户端和服务器的连接关系；

（4）Content-Length：描述HTTP消息实体的传输长度；

（5）Accept：发送端（客户端）希望接受的数据类型；

（6）Origin：浏览器referrer字段中只显示源网站的源地址；

（7）Authorization：请求所需的认证信息；

（8）User-Agent：客户端版本号的名字；

（9）Content-Type：请求实体，文档类型；

（10）Referer：从来于哪里；

（11）Accept-Encoding：客户端接收编码类型，一些网格压缩格式；

（12）Accept-Language：客户端接收的语言类型、中文；



###### 3、ref和reactive的区别？

（1）从定义数据方面：ref通常用来定义基本类型数据、reactive用来定义对象（或者数组）类型数据；ref也可以用来定义对象或者数组类型的数据，内部会通过reactive转为代理对象；

（2）从原理方面：ref通过ObjectProperty()的get和set实现数据代理，reactive使用Proxy实现数据代理，并且通过Reflect操作源对象内部的数据；

（3）从使用方面：ref操作数据需要value、template不需要。reactive都不需要；



###### 4、单页应用和多页应用的区别？

单页应用：就是刷新页面会请求HTML文件，但切换页面的时候，不会再次请求HTML文件，只是页面内容发生了变化而已；优点：页面切换块；缺点：首屏时间稍慢，搜索引擎差；

多页应用：每次切换页面都会发起http请求HTML文件；优点：首屏时间快，搜索引擎效果好，搜索引擎能识别HTML内容，根据内容进行排名；缺点：页面切换慢；



###### 5、data和computed的区别？

data中的属性并不会随赋值变量的改动而改动，而computed会；



###### 6、Vue的性能优化；

第三方模块按需引入、防抖、节流、v-if替代v-show、图片路由懒加载、异步组件；



###### 7、什么是防抖和节流？

防抖：n秒后再执行该事件，若在n秒内被重复触发，则重新计时；

节流：n秒内只运行一次，若在n秒内重复触发，只有一次生效；



###### 8、JS数组去重的方法？

（1）ES6 Set去重；

（2）利用for嵌套for，然后splice去重；

（3）利用indexOf去重；

（4）利用includes；



###### 9、清除浮动的方法

（1）使用带clear属性的空元素（在浮动元素后使用一个空元素，并在CSS赋予.clear {clear：both；}属性即可清理浮动）；

（2）使用CSS的overflow属性（给浮动元素的容器添加overflow：hidden；或overflow:auto;可以清除浮动，在IE6中还需要触发hasLayout）

（3）给浮动元素的容器添加浮动（给浮动元素的容器也添加上浮动属性即可清除内部浮动，但这样会使其整体浮动，影响布局）

（4）使用CSS的:after伪元素；



###### 10、有哪些方式可以隐藏页面？

display: none;

visibility: hidden;

opacity: 0;

设置height、width为0；

position：absolute；



##### 2023.03.15

###### 1、如何让CSS只在当前的文件中使用？

在style标签加上scoped



###### 2、说一说Vuex是什么，每个属性是干嘛的，如何使用 ？

Vuex是vue.js应用程序开发的状态管理模式，采用集中式存储管理应用的所有组件的状态，解决多组件数据通信；

（1）state：同一定义公共数据；

（2）mutations：使用它来修改数据；

（3）getters：类似于computed；

（4）actions：发起异步请求；

（5）modules：模块拆分；



###### 3、JS变量提升是什么？

指在JS代码执行过程中，JS引擎把变量的声明部分和函数的声明部分提升到代码开头的行为，变量被提升后，会给变量设置默认值为undefined。



###### 4、说几个未知宽高元素水平垂直居中方法？

参考0222的第四题



###### 5、forEach() 和 map()的区别？

相同点：

（1）都是循环遍历数组的每一项；

（2）每次执行匿名函数都支持三个参数；

（3）匿名函数中的this都是指向window；

（4）只能遍历数组；

不同点：

（1）map()会分配内存空间存储新数组并返回，foeEach()不会返回数据；

（2）forEach()允许callback更改原始数组的元素。map()返回新的数组；



###### 6、Vue中的method属性选项里面的函数为啥不能使用箭头函数？

在methods中要使用data返回对象中的数据，则该this须有值，且应可以通过this获取到data返回对象中的数据；该this不可以是window，因为window中无法获取到data返回对象中的数据，if为箭头函数，则该this就为window了；



###### 7、在第六问的基础上再问，在不使用箭头函数情况下，this指向什么？

Vue源码中对methods中的所有函数进行遍历，且通过bind绑定了this，this会指向所调用的对象；



###### 8、JS中能使对象发生变化的方法有什么？

（1）Object.defineProperty();

（2）new Proxy();



###### 9、Vue中绑定class的方式有哪些？

对象语法、数组语法；



###### 10、计算属性区别于methods的特性？

计算属性是有缓存的，会基于它们对的依赖属性关系进行缓存，数据不发生变化，则不需要重新计算的，但依赖的数据发生变化时，在使用的时候会重新计算；



##### 2023.03.16

###### 1、浏览器垃圾回收机制是什么？

标记清理、引用计数；



###### 2、JS继承方法的优缺点？

（1）原型链继承：

优点：将子类的原型指向父类的实例

缺点：引用类型的属性被所有实例共享，修改堆内存数据时会将所有实例数据都修改，但是直接创建新的存储对象就不会产生这个错误；创建子类实例时不能向超类型的构造函数中传递参数；

（2）借用构造函数（类式继承）

优点：能实现属性的继承，也可以在子类型创建实例时为父类型传递参数；

缺点：只能继承构造函数的属性和方法

（3）组合是继承：

优点：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承；

缺点：如果再添加一个子类型给这个子类型原型上单独添加一个方法那么其他子类型也同时拥有这个方法，因为都指向同一个父类型原型。

（4）原型式继承：

优点：没有创建自定义类型，只是套了个壳子返回对象；

缺点：没用到原型，无法复用；

（5）寄生继承：

优缺点：跟构造函数继承类似，调用一次函数就得创建一遍方法，无法实现函数复用，效率较低；

（6）寄生组合式继承：

结合组合继承优点、寄生继承优点，缺点是两次调用父级构造函数；



###### 3、Token能放在cookie中么？为什么？

可以，但最好不要放在cookie中，易产生CSRF问题；token是用来判断用户是否登录的，客户端输入用户名和密码，服务器收到请求，去验证用户名和密码，验证成功后，服务端签发一个token发送给客户端，客户端可以把它保存在cookie和localStorage应用下次验证登录，只要在cookie不设置时间即可。



###### 4、数组和伪数组的区别？

（1）伪数组与数组都属于对象，但是伪数组是基于Object构造函数创建的，数组是基于Array构造函数创建的，构造函数的方法写在其原型对象prototype开辟的内存内，基于构造函数创建的对象会拥有其方法。Object构造函数属于最顶级对象，因此根据原型链，伪数组只能拥有Object.prototype的属性值，不能拥有Array.prototype的属性值，因此不具有数组的方法。

（2）伪数组的长度作为对象的一个属性，不会随索引属性的改变而改变。



###### 5、说一下有什么方法可以保持前后端实时通信？

轮询、长轮询、iframe、webSocket、SSE；



###### 6、v-model的原理？

v-bind绑定value属性的值，v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中；



###### 7、你怎么理解v-model的值绑定？

数据来自服务器，先请求值下来，绑定到data返回的对象中，通过v-bind来进行值的绑定；



###### 8、v-model中的.lazy修饰符是什么作用？

默认情况下，v-model在进行双向绑定的是input事件，则会在每次内容输入后就将最新的值和绑定的属性进行同步，如果在v-model后跟上lazy修饰符，则会将绑定的事件切换为change事件，只有在提交时（如回车）才会触发；



###### 9、Vue注册组件的方式；

全局注册：app.component()；

局部注册：通过components属性选项来注册；



###### 10、单文件的特点？

（1）代码高亮；

（2）ES6、commonJS的模块化能力；

（3）组件作用域的CSS；

（4）可使用预处理器来构建更丰富的组件；



##### 2023.03.17

###### 1、如何避免重绘或重排？

触发动画的开始不要用display：none属性，会引起Layout、Paint环节；translate属性值来替换top/left//right/bottom的切换，scale属性值替换width/height，opacity属性值替换display/visibility等；



###### 2、Vue-router实现懒加载的方法？

（1）异步组件实现：指在组件中使用import()动态导入组件，从而实现组件的懒加载（按需加载）；

（2）使用动态导入：通过import()方法动态加载模块，可以用于加载组件，也可以用于加载其他模块；



###### 3、扩展运算符（...）的使用场景?

对象：取出参数对象中的所有可遍历属性，拷贝到当前对象中，属于浅拷贝；

数组：可将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

（1）将数组转换为参数序列；

（2）复制数组；

（3）合并数组；

（4）扩展运算符与解构赋值结合起来，用于生成数组；

（5）将字符串转为真正的数组；

（6）任何Iterator接口的对象，都可以通过扩展运算符转为真正的数组；

（7）使用Math函数获取数组中特定的值；



###### 4、ajax请求的过程是什么样的？

（1）创建‘XMLHttpRequest’对象，即创建一个异步调用对象；

（2）创建一个新的‘Http’请求，并指定该‘HTTP’请求的方法、‘URL’及验证信息；

（3）设置响应‘HTTP’请求状态变化的函数；

（4）发送‘HTTP’请求；

（5）获取异步调用返回的数据；



###### 5、let a = 1 

   function b(a) { a = 2 console.log(a) }
      b(a)
    console.log(a) 最终会输出什么？

输出2,1



###### 6、什么是props？

组件上可以注册一些自定义attribute，父组件给这些attribute赋值，子组件通过attribute的名称获取到对应的值；



###### 7、props的type都可以为哪些？

String、Number、Boolean、Array、Object、Date、Function、Symbol；



###### 8、什么是非prop的attribute?

当传递给一个组件某个属性，但该属性并无定义对应props或emits时，称之为非props的attribute；



###### 9、子组件传递父组件的步骤？

（1）在子组件上定义好某些情况下触发的事件名称；

（2）父组件中以v-on方式传入要监听的事件名称；

（3）在子组件中发生某个事件时，根据事件名触发对应事件；



###### 10、什么栈内存，什么是堆内存？

栈内存：基本类型的数据和对象的引用；

堆内存：new产生的数据和数组；



##### 2023.03.20

###### 1、{} 和 [] 的 valueOf 和 toString 的结果是什么？

{}：valueOf()输出{}，toString()输出[object Object]；

[]：valueOf()输出[]，toString()输出空（空格的空）；



###### 2、如何将字符串转化为数字，例如 '12.3b'?

parseInt('12.3b')



###### 3、javascript 代码中的 "use strict"; 是什么意思 ? 使用它区别是什么？

目的是指定代码在严格模式条件下执行，严格模式下不能使用未声明的变量；

使用严格模式：消除JS语法一些不合理、不严谨之处，减少一些怪异行为；消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度；体现了JS更合理、更安全、更严谨的发展方向；在严格模式中，会有不一样的运行结果；一些在正常模式下可运行的语句，在严格模式下将不能运行。



###### 4、如何判断一个对象是否属于某个类？

（1）使用instanceof运算符判断；

（2）使用typeof判断；

（3）使用constructor判断；

（4）使用Object.prototype.toString.call()判断（可以精准判断所以类型）



###### 5、js 延迟加载的方式有哪些？

（1）defer属性；

（2）async属性；

（3）动态创建DOM；

（4）使用jq的getScript方法；

（5）使用setTimeout延迟加载脚本；

（6）将script引入放在最后加载；



###### 6、前端页面有哪三层构成，分别是什么？

网页分为三个层次，即：结构层、表示层、行为层；

（1）网络结构层：由HTML或XHTML之类的标记语言负责构建。标签，也就是那些出现在尖括号里的单词，对网络内容的语义含义做出这些标签不包含任何关于如何显示有关内容的信息；

（2）网页表示层：由CSS负责创建，CSS对“如何显示有关内容“的问题做出了回答；

（3）网页行为层：负责回答”内容应该如何对事件做出反应“这一问题。



###### 7、什么是Ajax?

包括：

（1）XHTML和CSS；

（2）使用DOM作动态显示和交互；

（3）使用XML和XSLT做数据交互和操作；

（4）使用XMLHttpRequest进行异步数据接收；

（5）使用JS将它们绑在一起；



###### 8、阐述Vue的响应式原理；

当一个Vue实例创建时，Vue会遍历data选项属性，用Object.defineProperty将它们转为getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的watcher程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新；



###### 9、delete和Vue.delete删除数组的区别；

delete只是被删除的元素变成了empty/undefined其他的元素的键值还是不变。Vue.delete直接删除了数组改变了数组的键值；



###### 10、什么是柯里化？

柯里化是一种把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。在JS应用中，可以传递一个或多个参数；



##### 2023.03.21

###### 1、input中disabled与readonly有何区别？

相同点：都会使文本框变成只读，不可编辑；

不同点：

（1）disabled属性在将input文本框变成只读不可编辑的同时，还会使文本框变灰，但readonly不会；

（2）disabled属性修饰后的文本框内容，在不可编辑的同时，通过JS也是获取不到的。

（3）disabled属性对input文本框，单选框radio，多选checkbox都适用，但是readonlt就不适用了，用它修饰后的单选以及多选按钮仍然是可以编辑状态。



###### 2、table的合并边框属性是什么？跨行是什么？跨列是什么？

边框合并：cellspacing = 0

跨行属性：colspan

跨列属性：rowspan



###### 3、split() join()的区别在哪？

split()方法是切割数组的形式，join()是将数组转换成字符串；



###### 4、请你谈谈Cookie的弊端？

（1）cookie的长度和数量的限制，同一个domain下只能存放20条，每条4KB，否则会被截掉；

（2）安全性问题，如果cookie被截取，截取者就能获取session的信息；

（3）有些状态不能保存到客户端；



###### 5、请说出三种减少页面加载时间的方法？

（1）减少HTTP请求；

（2）优化图片，减少其尺寸；

（3）选择合适的图像格式；

（4）压缩JS、CSS代码，把CSS放在顶部，把JS放在底部，最好把CSS和JS放到外部文件；

（5）服务器启用gzip功能；

（6）标明宽度及高度；

（7）网址后面加/（加/会减少一次判断过程，直接返回网站设置的存放在网站根目录下的默认页面）

（8）避免空的src和href;

（9）避免跳转；

（10）使用get来完成Ajax请求；



###### 6、Vue3中setup函数不可用this的原因？

this并无指向当前组件实例，且在setup调用之前，data、computed、methods等没被解析，因此无法在setup中获取this；



###### 7、Vue中如何使用slot？

Vue中将<slot>元素作为承载分发内容的出口，在封装组件中，使用特殊的元素<slot>就可以封装为组件开启一个插槽，该插槽插入什么内容取决于父组件如何使用。



###### 8、哪些语句会导致在作用域临时添加一个上下文？

（1）try/catch语句：catch会创建一个新的变量对象；

（2）with语句：添加指定对象；



###### 9、margin和padding的区别？

作用对象不同，padding针对于自身的，margin作用于外部对象的。



###### 10、什么是深拷贝，什么是浅拷贝？

浅拷贝：是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本属性，拷贝的就是基本类型的值，如果属性是应用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

深拷贝：是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟了一个新的区域存放新对象，且修改新对象不会影响原对象。



##### 2023.03.22

###### 1、innerHTML和outerHTML有什么区别？

innerHTML：从对象的起始位置到终止位置的全部内容，不包括HTML标签；

outerHTML：除了包含innerHTML的全部内容外，还包含对象标签本身；



###### 2、有关CSS属性position属性值的描述？

position属性指定一个元素（静态的、相对的、绝对的或固定的）的定位方法的类型；



###### 3、HTML、XHTML、XML、HTML5区别？

XHTML是HTML的基础上向XML过渡的东西，和HTML最大的区别就在于它更为严谨且语义化更强；

XHTML与HTML区别：

XHTML元素必须被正确地嵌套，元素必须被关闭，标签名必须用小写字母，必须拥有根元素；所有的XHTML文档必须拥有DOCTYPE声明，且html、head、title和body元素必须存在；XML语法要求更为严格；



###### 4、前端如何定跳页面？

onClick跳转：

（1）设置window的location.href属性；

（2）调用window的open方法；

a标签跳转；



###### 5、如何阻止事件冒泡和默认事件？

（1）event.stopPropagation()方法；

（2）event.preventDefault()方法；

（3）return false;



###### 6、Vue性能优化

第三方模块按需引入、防抖、节流、v-if代替v-show、图片路由懒加载、异步组件；



###### 7、http如何实现缓存？

强缓存：Expirse（过期时间）、Cache-Control（no-cache）协商缓存

浏览器会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源，否则，根据头信息向服务器发送请求，使用协商缓存，如果命中，则服务器不返回资源，浏览器直接使用本地资源的副本，如不命中，则浏览器返回最新的资源给浏览器；



###### 8、vw和百分比有什么区别？

百分比有继承关系，继承至父级；vw只和设备的宽度有关系；



###### 9、Loader和Plugin有什么区别？

Loader：加载器，webpack将一切文件视为模块，但webpack原生只能解析js文件，如果想将其他文件也打包的话，就会用到loader，所以loader的作用是让webpack拥有了加载和解析非JS文件的能力；

Plugin：插件，Plugin可以扩展webpack的功能，让webpack具有更多的灵活性，在webpack运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过webpack提供API改变输出结果；



###### 10、什么是Vue生命周期？

Vue实例从创建到销毁的过程，即从开始创建、初始化数据、编译模板、挂载DOM->渲染、更新->渲染、卸载等一系列过程；



##### 2023.03.23

###### 1、$set作用是什么？

用来更新数组或对象，接收三个参数：

参数1：需要更新的数组或对象；

参数2：数组的下标或对象的属性名；

参数3：更新的内容；



###### 2、function a(b = c, c = 1) {console.log(b, c)} a();最后输出的是什么？

会抛出ReferenceError;



###### 3、forEach和Map的区别？

相同点：

（1）都是循环遍历数组中的每一项；

（2）每次执行匿名函数都支持三个参数，参数分别为item,index,arr;

（3）匿名函数中的this都是指向window的；

（4）只会遍历数组；

不同点：

（1）map()会分配内存空间存储新数组并返回，forEach()不会返回数据；

（2）forEach()允许callback更改原始数组的元素，map()返回新的数组；

forEach()针对每一个元素执行提供的函数，对数据操作会改变原数组。

map()不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；

map()适用于你要改变数据值的时候。不仅仅在于它更快，并且返回一个新的数组；



###### 4、怎样避免全局变量污染？

（1）使用let或const定义变量：使用let或const定义变量可以将变量限定在块级作用域中，从而避免变量泄漏到全局作用域中；

（2）使用闭包：可以将变量限制在函数作用域中，防止变量泄漏到全局作用域中；

（3）使用模块化开发：可以将代码按照功能模块进行组织，从而避免全局变量的产生；

（4）使用命名空间：可以将变量名进行空间隔离，从而避免不同模块之间的变量冲突；

（5）使用严格模式：可以禁用一些不安全的JS语法，从而减少意外的全局变量污染；



###### 5、socket和websocket的区别？

（1）socket是传输控制层协议，websocket是应用层协议；

（2）websocket是双向通信协议， 模拟socket协议，可以双向发送或接受信息。http是单向的。

（3）websocket是需要握手进行建立连接的，反复通信就要用websocket；



###### 6、常见的浏览器兼容性；

浏览器种类多、内核种类多、对于CSS3的部分属性不能完全兼容，条件注释、选择前缀法；



###### 7、Vue3中reactive和ref的区别？

（1）从定义数据方面：ref常用来定义基本类型数据，reactive用来定义对象或数组，ref也可以用来定义对象或数组类型的数据，内部会通过reactive转为代理对象；

（2）从原理方面：ref通过Object.defineProperty()的get和set实现数据代理；reactive使用Proxy实现数据代理，并且通过Reflect操作源对象内部的数据。

（3）从使用方面：reactive不需要value，ref操作数据需要value，template模板中不需要；



###### 8、什么是图片的懒加载？

当页面滚动的事件被触发->执行加载图片操作->判断图片是否在可视区域内->在，则动态将data-src的值赋予该图片；



###### 9、线程跟进程的区别？

一个程序至少有一个进程，一个进程至少有一个线程；线程的划分尺度小于进程，使得多线程程序的并发性高；进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率；线程在执行过程中与进程还是有区别的，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制；从逻辑角度看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配；



###### 10、如何提高websocket构建速度？

组件的懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置include/exclude缩小Loader对文件的搜索范围、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度；





##### 2023.03.24

###### 1、

let a = b = 10;

(function(){   let a = b = 20  })() console.log(a) console.log(b)

最终会输出什么？

10

20



###### 2、前端异常监控的方式有哪些？

try-catch异常处理、window.onerror异常处理、Promise错误



###### 3、绝对定位和相对定位的区别？

（1）主体不同：

1、相对定位：是设置为相对定位的元素框会编译某个距离。

2、绝对定位：absolute脱离文档流，通过top，bottom、left、right定位；

（2）特点不同：

1、相对定位：在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间，因此，移动元素会导致它覆盖其他框；

2、绝对定位：选取其最近的父级定位元素，当父级position为static时，absolute元素将以body坐标原点进行定位，可以通过z-index进行层次分级；



###### 4、mouseover和mouseenter的区别？

mouseover是冒泡的，而mouseenter是不冒泡的；



###### 5、解决异步回调地狱的方法？

Promise、Generator、async/await；



###### 6、谈谈你对mixin的理解；

mixin(混入)，它提供了一种非常灵活的方式，来分发Vue组件中的可复用功能。

使用场景：不同组件中经常会用到一些相同或系那个是的代码，这些代码的功能相对独立。可以通过mixin将相同或相似的代码提出来；

缺点：

（1）变量来源不明确；

（2）多mixin可能会造成命名冲突；（解决：使用Vue3的组合API）

（3）mixin和组件出现多对多的关系，使项目复杂度变高；



###### 7、什么是动态路由？

需要将给定匹配模式的路由映射到同一个组件；例：我们有一个User组件，对于所有ID各不相同的用户，都要使用这个组件来渲染。那么，我们可以在vue-router的路由路径中使用动态路径参数来达到这个效果：{path:'/user/:id', component: User},其中 :id 就是动态路径参数；



###### 8、Vue的模板编译原理？

Vue中有个独特的编译器模块，为：compiler，主要作用是将用户编写的template编译为js中可执行的render函数。在Vue中，编译器会先对template进行解析，这一步称为parse，结束之后得到一个JS对象，称为抽象语法书AST；然后就是对AST进行深加工的转换过程，这一步称为transform，最后将前面得到的AST生成JS代码，即render函数；



###### 9、Vue实例挂载过程中发生了什么？

挂载过程指的是app.mount()过程，这是一个初始化过程，整体上做了两件事情：初始化和建立更新机制。初始化会创建组件实例、初始化组件状态、创建各种响应式数据。

建立更新机制这一步会立即执行一次组件的更新函数，这会首次执行组件渲染函数并执行patch，将vnode转换为dom；同时首次执行渲染函数会创建它内部响应式数据和组件更新函数之间的依赖关系，这使得以后数据发生变化时会执行对应的更新函数；



###### 10、谈谈你对以下代码输出的理解

![image-20230324220135078](C:\Users\GG-BOND\AppData\Roaming\Typora\typora-user-images\image-20230324220135078.png)

new关键字：

（1）创建了一个空对象

（2）实例对象obj的隐式原型要与构造函数的显式原型指向相同；

（3）将构造函数内部的this与实例对象做绑定，并对构造函数内部的值做赋值操作；

（4）根据构造函数的返回值类型缺点新创建的实例对象具体值；

创建了A对象赋值给了a，则a是一个{}，输出a的时候，则为一个{}，由于在A()并没有定义name这个属性（因为if条件不成立），输出a.name会从A的原型链中继续寻找；当创建B()由于没有if条件，会创建一个name属性，由于cName在创建B()的时候没有赋初值，导致undefined，当输出的时候b.name已经存在了，只是值为undefined而已；





##### 2023.03.27

###### 1、怎样理解Vue单选数据流？

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原数据进行修改；



###### 2、DOM如何实现浏览器内多个标签页之间的通信？

（1）webSocket.SharedWoeket;

（2）也可以调用localStorage、cookies等本地存储方式；localStorage另一个浏览器上下文里被添加、修改或删除时，都会触发一个事件，通过监听事件，控制他的值进行页面信息通信；

（3）quirks:Safari在无痕模式设置localStorage值时会抛出，quotaExceededError的异常；



###### 3、什么原因会造成内存泄漏？

（1）全局变量使用不当（没有声明的变量）；

（2）闭包使用不当；

（3）定时器/延时器没有清理；

（4）没有清理的DOM元素引用（DOM清空或删除时，事件未清除）



###### 4、如何解决盒子塌陷？

（1）父盒子设置上边距；

（2）overflow：hidden；

（3）子盒子脱标；

（4）父盒子上padding；



###### 5、什么是Symbol？

是ES6引入新的原始数据类型，表示独一无二的值；



###### 6、函数作用域有哪几种？

全局、局部、块级；



###### 7、图片的预加载和懒加载的区别？

预加载：在网页全部加载之前，提前加载图片，当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间；

懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片；



###### 8、使用箭头函数应注意什么？

（1）箭头函数没有prototype，所以箭头函数本身没有this，即不能用call()、apply()、bind()这些方法改变this的指向；

（2）箭头函数的this指向在定义的时候继承自外层第一个普通函数的this，如果箭头函数外层没有普通函数，它的this会指向window；

（3）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象；

（4）箭头函数没有contructor，使用new调用箭头函数都会报错；

（5）箭头函数的arguments

第一种情况：箭头函数的this指向全局对象，会报arguments未声明的错误；

第二种情况：箭头函数的this如果指向普通函数，它的arguments继承于该普通函数；

（6）不可以使用yield命令，因此箭头函数不能用作Generator函数；



###### 9、如何实现高度自适应？

（1）非浮动元素的父元素高度自适应；

（2）浮动元素的父元素高度自适应；



###### 10、ES6中的Map()和原生的对象有什么区别? 

（1）原生Object对象存储键值对组合中键的类型是字符串，map对象存储键值对的类型可以是任意类型；

（2）原生Object对象获取键值使用的是Object.keys，返回的是数组，而map对象采用的是“map变量.keys()”



##### 2023.03.28

###### 1、iframe的优缺点？

优点：解决加载缓慢的第三方内容如图标和广告等的加载问题；Security sandbox;并行加载脚本；

缺点：iframe会阻塞主页面的Onload事件，即时内容为空，加载也需要事件；没有语意；



###### 2、rgba和opacity的透明效果有什么不同？

opacity会继承父元素的opacity属性，而RGBA设置的元素的后代不会继承不透明属性。



###### 3、position的值，relative和absolute分别是相对于谁进行定位的？

relative相对定位，相对于自己本身在正常文档流中的位置进行定位；

absolute：生成绝对定位，相对于最近一级定位不为static的父元素进行定位；

fixed(老版本IE不支持)：生成绝对定位，相对于浏览器窗口或者frame进行定位；

static(默认值)：没有定位，元素出现在正常的文档流中；

sticky：生成粘性定位的元素，容器的位置根据正常文档流计算得出；



###### 4、闭包常用场景？

设置私有变量的方法



###### 5、什么是Vue SSR?

SSR即Vue在客户端将标签渲染成的整个html片段的工作在服务端完成，服务端形成的html片段直接返回给客户端这个过程就叫服务端渲染；



###### 6、MVVM的理解

MVVM分为Model、View、ViewModel三者；

Model代表数据模型，数据和业务逻辑都在Model层中定义；

View代表UI视图，负责数据的展示；

ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；

Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有双向数据绑定的联系。因此当Model中数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作DOM；



###### 7、vue-router两个页面之间的传值；

参数传值：传值最好将字典，数组类型的转成json字符串；

缓存传值：本地存、用的时候存；



###### 8、前端的资源动态加载的方法有哪些？

（1）利用ajax方式，把script文件代码从背景加载到前台，而后对加载到的内容经过eval()实施代码；

（2）动静创建一个script标签，配置其src属性，经过把script标签插入到页面head来加载js，相当于在head中写了一个，只是此script标签是用js动静创建的；



###### 9、解决Vuex页面刷新数据丢失问题；

（1）直接在Vuex修改数据方法中将数据存储到浏览器本地存储中；

（2）利用第三方哭进行持久化存储；



###### 10、

console.log(1 + {});  输出1 [object Object]

console.log(1 + []);   输出 1 

console.log([] + {})   输出[object Object]



##### 2023.03.29

###### 1、如何解决循环依赖的问题？

Webpack中将require替换为webpack_require,会根据moduleId到installedModules找是否加载过，加载过则直接返回之前的export，不会重复加载；



###### 2、如何提高webpack构建速度；

组件懒加载、路由懒加载、开启gzip、公共的第三方包上cdn、配置include/exclude缩小Loader对文件的搜索范围、配置cache缓存Loader对文件的编译副本、配置resolve提高文件的搜索速度（@：src）



###### 3、Vue原理总结；

【模板编译】：将template模板，经过编译系统后生成VNode(模板字符串->AST->Render函数)

【渲染】然后再通过渲染系统来将VNode生成真实DOM（document.createElement&&Mount挂载到真实DOM节点上）

【响应式】通过响应式系统对数据进行监听，当数据发生改变时，触发依赖项（组件）

【Diff&Patch】组件内手动通知后，会通过diff算法对比VNode的变化，尽可能复用代码，找出最小差异，保证性能消耗最小。

【渲染】拿到需要新增/删除/修改的VNode后，逐一去操作真实DOM进行修改（通过选择器选择到对应真实DOM节点进行修改）



###### 4、Vue2和Vue3的响应式原理有什么区别？

Vue2用的是Object.defineProperty，Vue3用的是Proxy；

Object.defineProperty缺点：

1、一次只能对一个属性进行监听，需要遍历来对所以属性监听；

2、对于对象的新增属性，需要手动监听；

3、对于数组通过push、unshift方法增加的元素，也无法监听；

Proxy就无这些问题，可以监听整个对象数据的变化；



###### 5、虚拟DOM实现原理？

用JS对象模拟真实DOM树，对真实DOM进行抽象；

diff算法：比较两棵虚拟树的差异；

patch算法：将两个虚拟DOM对象的差异应用到真的的DOM树；



###### 6、Vue事件绑定原理？

（1）原生的事件绑定：采用的是addEventListener实现；

（2）组件的事件绑定：组件绑定事件采用$on方法；



###### 7、slot是什么？有什么作用？

slot插槽，可理解为slot在组件模板中提前占据了位置，当复用组件时，使用相关的slot标签时，标签里的内容就会自动替换组件模板中对应slot标签的位置，作为承载分发内容的出口；

作用：复用和扩展组件，做一些定制化组件的处理；



###### 8、template预编译是什么？

将template转化为render function，这个过程，可以在项目构建中完成，这样可以让实际组件在runtime时直接跳过模板渲染，进而提升性能，这个在项目构建的编译template的过程，就是预编译；



###### 9、nextTick是怎么可以获取到更新后的DOM？

Vue是异步执行DOM更新的，一旦观察到数据变化，不会马上更新DOM，而是Vue会开启一个队列，然后把在同一个事件循环中观察到数据变化的watcher推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOM操作，而在下一个事件循环时，Vue会清空队列，并进行必要DOM更新；



###### 10、说一下JSON.stringify有什么缺点？

（1）如果obj属性有时间对象，则JSON.stringify后再JSON.parse的结果，时间将转为字符串的形式，而不是对象形式；

（2）如果obj的属性有RegExp、Error对象，则序列化的结果将只得到空对象；

（3）如果obj的属性有函数、undefined、Symbol,则序列化的结果会把function或undefined丢失；

（4）如有属性NaN、Infinity和-Infinity，则序列化的结果会变成null；

（5）只能序列化对象的可枚举的自有属性，如果obj中的对象是由构造函数生成的，则使用JSON.parse（JSON.stringify（obj）)深拷贝后，会丢弃对象的constructor；

（6）如对象存在循环引用的情况也无法正确实现深拷贝，并且会导致死循环，最后抛出异常；



##### 2023.03.30

###### 1、什么是WebStorage？

webStorage是html5引入的非常重要的功能，可以将数据存储在本地，用户在浏览器中刷新网页时，网页通过webStorage就可以知道用户之前所做的一些修改，而不需要将用户修改的内容存储在服务端；包含两个关键的对象，为localStorage对象和sessionStorage对象；



###### 2、背景透明的方法可以怎么实现？

style里面的background设置为transparent



###### 3、src和href的区别？

参考0306的第一题



###### 4、title与h1、b与strong、i与em的区别？

title与h1区别：title是网站标题，一个页面只能有一个，h1是文章标题，一个页面可以有篇文章，所以可以有多个好；

b与strong区别：b标签只是加粗的样式，无实际含义，常用语表达无强调或着中意味的粗体文字，strong表示标签内字符重要，用以强调，其默认格式是加粗，但可以通过css添加样式，使用别的样式强调；

i与em的区别：i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体；em表示标签内字符重要，用以强调，其默认格式是斜体，可以通过css添加样式；



###### 5、怎么处理文档流，文本流清除浮动？

清除浮动：

（1）直接设置父元素高度

（2）直接给父元素设置overflow:hidden

（3）额外标签法；

（4）单伪元素法；

（5）双伪元素法；



###### 6、增强对象语法有哪些？

属性值简写、可计算属性、简写方法名；



###### 7、Map和Object作为键的区别？

Object只能使用数值、字符串与符号作为键不同

Map可以使用任何JS数据类型作为键；



###### 8、谈谈你能列举数组添加元素的方法；

（1）改变数组的length属性；

（2）push()方法；

（3）unshift()方法；

（4）splice()方法；



###### 9、接收可迭代对象的原生属性包括哪些？

（1）for...of;

（2）数组解构；

（3）扩展运算符；

（4）Array.from();

（5）创建集合(Map)；

（6）创建映射(Set)；

（7）Promise.all()接收由期约组成的可迭代对象；

（8）Promise.race()

（9）yield * 操作符，在生成器中使用；



###### 10、 什么是定型数组？

目的是提升向原生库传输数据的效率，指的是一种特殊的包含数组类型的数组；



##### 2023.03.31

###### 1、active-class 是哪个组件的属性？

是vue-router模块中router-link组件中的属性；



###### 2、怎么判断是否是一个数组？

（1）instanceof()

（2）constructor

（3）Object.prototype.toString.call()

（4）Array.isArray()



###### 3、数组排序的方法

插入法、选择排序法、归并排序



###### 4、将伪数组转换为真数组的方法

（1）准备一个新的空数组，然后遍历伪数组，将伪数组中的值通过索引逐个添加到新数组中；

（2）利用扩展运算符（...）将伪数组转化为真数组【ES6】；

（3）利用Array的原型对象的slice()方法，配合call()方法修改slice中的this指向；

（4）利用Array.from()方法



###### 5、 ES6中的class继承，constructor()和 super()关键字分别作用是什么？

super关键字：用于调用一个对象的父对象上的函数；

（1）super作为函数调用，代表父类的构造函数；

（2）super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类；

constructor关键字：构造方法是创建和初始化使用类创建的一个对象的一种特殊方法；



###### 6、请阐述table的缺点

（1）嵌套太深，如：table>tr>td>h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了冗余代码量；

（2）灵活性差，比如要将tr设置border等属性，必须得通过td；

（3）代码臃肿，当在table中套用table的时候，阅读代码会显得异常混乱；

（4）混乱的colspan与rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱；

（5）不够语义；



###### 7、div+css的布局较table布局有什么优点？

（1）改版的时候更方便只要改css文件；

（2）页面加载速度更快、结构化清晰、页面显示简洁；

（3）表现与结构相分离；

（4）易于优化（seo）搜索引擎更友好，排名更易靠前；



###### 8、强缓存和协商缓存；

浏览器缓存特点：

浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识；

浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中；

根据是否需要向服务器重新发起HTTP请求将缓存过程分为两部分，分别是强制缓存和协商缓存；

协商缓存：就是强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识觉得是否使用缓存的过程。

协商缓存主要有以下两种情况：

协商缓存失效，返回304；

协商缓存失效，返回200和请求结果



###### 9、为什么利用多个域名来存储网站资源会更有效？

（1）CDN缓存更方便；

（2）突破浏览器并发限制；

（3）节约cookie带宽；

（4）节约主域名的连接数，优化页面响应速度；

（5）防止不必要的安全问题；



###### 10、keep-alive中的生命周期有哪些？

keep-alive是Vue提供的一个内置组件，用来对组件进行缓存，在组件切换过程中将状态保留在内存中，防止重复渲染DOM。如果为一个组件包裹了keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy和destroyed就不会再被触发了，因为组件不会被真正销毁。当组件被换掉时，会被缓存到内存中、触发deactivated生命周期；当组件被切回来时，再去缓存里找这个组件、触发activated钩子函数；



##### 2023.04.03

###### 1、生命周期中created，mounted两个步骤分别做了什么操作？

created：在组件实例处理完所有与状态相关的选项后调用；当该钩子被调用时，响应式数据、计算属性、方法和侦听器等已经设置完成；此时挂载阶段还未开始，因此$el属性仍不可用；

mounted：在组件被挂载之后调用；组件被视为已挂载情况：所有同步子组件都已经被挂载；其自身的DOM树已经创建完成并插入了父容器中。（仅当根容器在文档中时，才可以保证组件DOM树也在文档中）



###### 2、vue中渐进式是什么意思？

主张少，没有多做职责之外的事；使用Vue时，不需要在创建工程时全部引入，每一部分都是相互独立，可单独被使用；



###### 3、单纯的借用构造函数继承有什么缺陷

会调用两次超类型构造函数：一次在创建子类型原型的时候，另一次是在子类型构造函数内部。虽然子类型最终会包含超类型对象的全部实例属性，但不得不在调用子类型构造函数时重写这些属性；



###### 4、创建对象的方式有哪些？

（1）new Object()：使用new字符创建对象；

（2）通过字面量去创建对象；

（3）自定义构造函数创建对象；

（4）工厂模式创建对象；



###### 5、事件绑定的方式有哪些？ 

（1）在DOM中元素中直接绑定；

（2）在JS代码中绑定；

（3）绑定事件监听函数；



###### 6、WEB攻击有哪些？

（1）XSS

（2）CSRF

（3）点击攻击：clickjacking

（4）SQL注入

（5）OS命令注入

（6）请求劫持

（7）DDOS

（8）标签安全



###### 7、async/await的错误捕获方式？

（1）try...catch

（2）await-to-js库

（3）await Promise对象.catch(e => {...})



###### 8、伪元素、伪类区别？

（1）伪元素主要是用来创建一些不存在原有DOM结构树中的元素，例：用::before和::after在一些存在的元素前后添加文字样式等；这些被添加的内容会以具体的UI显示出来，被用户所看到，这些内容不会改变文档的内容，不会出现在DOM中，不可复制，仅仅在CSS渲染层加入。CSS3中建议使用::表示伪元素；

（2）伪类表示依存在的某个元素处于某种状态，但是通过DOM树又无法表示这种状态，就可以通过伪类来为其添加样式；

In sum：伪元素的操作对象是新生成的DOM元素，而不是原来DOM结构里就存在的，而伪类恰好相反，伪类的操作对象是原来的DOM结构里就存在的元素；



###### 9、浏览器样式兼容

（1）不同浏览器的标签默认的内外边距不同，可以全初始化为0；

（2）图片<img>和<a>标签在IE9中会有边框，解决方法：border：none；

（3）margin边距重叠，取最大值，舍弃小值；尽可能用padding；

（4）IE6及耕地版本中，部分块级元素有默认高度，解决方法：font-size：0；

（5）<a>标签蓝色边框：outline：none；

（6）IE6不支持min-height属性：

​		min-height：200px；_height:200px;overflow:visiable;

（7）IE9以下浏览器不能使用opacity

（8）IE6、7不支持display：inline-block

（9）cursor兼容问题；

（10）在Chrome中，字体不能小于10px；



###### 10、box-sizing所有的属性；

content-box、border-box、inherit



##### 2023.04.04

###### 1、禁止div标签点击事件的方法；

（1）CSS中添加pointer-events: none;

（2）在进入该点击事件时添加条件判断，然后return出去；

（3）event.stopPropagation()



###### 2、css中可以做动画效果的是哪个属性

animation（动画）、transition（过渡）



###### 3、

```js
var a={},    

b={key:'b'},    

c={key:'c'} 

a[b]=123 

a[c]=456 

console.log(a[b]) 
```

会输出什么？

456



###### 4、如何获取一个安全的undefined值

void 0，由于void 0没有返回值，因为返回结果是undefined，void并不改变表达式的结果，只是让表达式不返回值，因此可以用void 0来获取undefined；



###### 5、检查当前浏览器版本的方法？

（1）presto内核：opera浏览器中有个特有的window.opera对象，通过opera.version()可直接获取版本号；

（2）webkit内核：webkit内核的浏览器中window对象一下成员以“WebkKitXxxxx”开头，这是有别于其他浏览器内核的独特特征；

（3）Gecko内核：依然保留着window.netscape对象，且navigator.product值为“Gecko”

（4）IE：可以通过document.documentMode判断IE8以上的版本号；



###### 6、script标签放在header里和放在body底部里有什么区别？

放在header中：能看到html第一时间被加载进来，但页面body内容迟迟没有渲染出来，因为等待header标签中script脚本的加载，3s后，整个页面渲染完成；

放在body底部：这次html内容第一时间渲染完成，随着等待JS的加载；

In sum：

脚本会阻塞页面的渲染，所以推荐将其放在body底部，因为解析到script标签时，通常页面的大部分内容都已经渲染完成，让用户马上能看到一个非空白页面；

多个脚本之间都是异步向服务器请求，之间不相互影响；



###### 7、什么是HTML？

HTML即超文本标记语言，非编程语言，而是一种用来告知浏览器如何组织页面的标记语言，用来描述网页的表现，展现效果或功能及行为；



###### 8、连续空格如何渲染，意义是什么？

（1）为了代码的可读性，开发者通常会在HTML元素嵌套中使用空白；

（2）空白可以使用空格或TAB缩进实现；

（3）HTML解析器会将连续出现的空白字符减少为一个单独的空格符；

（4）使用连续空格，可以使用全角空格或实体字符&nbsp;



###### 9、谈谈内存中的栈和堆；

栈：先进后出，自动分配释放；

堆：先进先出，手动释放，容易内存泄漏；

基本数据类型存放在栈内存的简单数据段，引用型存放在堆内存中，实际栈保存的是一个指针；



###### 10、浅拷贝的实现方式；

（1）展开运算符...

（2）Object.assiggn()

（3）Array.prototype.concat()

（4）Array.prototype。slice()



##### 2023.04.05

###### 1、Vue中，异步请求适合在哪个生命周期调用？

可在钩子函数created、beforeMount、mounted中进行调用，因为在这三个钩子函数在，data已经创建，可以将服务端端返回的数据进行赋值，一般在created钩子函数中调用异步请求，能更快获取到服务端数据，减少页面loading时间；



###### 2、过滤器的作用以及使用场景？

过滤器是用来过滤数据的，在vue中使用filters来过滤数据，使用场景：如（时间/日期 格式化）



###### 3、为什么避免v-for和v-if同时使用？

v-for比v-if优先级高，使用的话每次v-for都会v-if判断，影响性能



###### 4、vue-router有哪几种导航守卫？

全局守卫、路由独享守卫、路由组件内的守卫

全局的路由钩子函数：beforeEach、afterEach

单个路由钩子函数：beforeEnter

组件内的路由钩子函数：beforeRouteEnter、beforeRouteLeave、beforeRouteUpdate



###### 5、Vue中的父子组件生命周期钩子函数执行顺序？

<!--加载渲染过程-->

<!--父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted-->

<!--子组件更新过程-->

<!--父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated-->

<!--父组件更新过程-->

<!--父beforeUpdate -> 父updated-->

<!--销毁过程-->

<!--父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed-->



###### 6、使用JS实现获取文件扩展名；

（1）使用正则表达式；

（2）使用String中的split方法；

（3）使用String的lastIndexOf方法；



###### 7、0.1 + 0.2 ！== 0.3的原因是为什么？

根据语言规范，JS采用遵循“IEEE754标准的双精度64位格式”表示数字；

0.1和0.2的二进制表示形式是不准确的，所以相加时，结果不是精确的0.3，而是非常接近的值0.30000000000000004；

这和JS采用“遵循IEEE754标准的双精度64位格式”有关；

1位存储符号，0表示正数，1表示负数；

用11位存储指数，指数必须是“有符号”的值，这里使用了偏差指数，即存储E+bias的值，对于11位来说，bias的值是2^(11-1) - 1，即1023。11位无符号正数的值的范围是0到2^11（2047），由于全0和全1的指数值是为特殊数字保留的，所以可用的指数是从1到2046.减去指数偏差值1023，就可得到指数的实际范围，即从-1022到+1023；

用52位存储小数部分

当0.1存下来的时候，就发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数，所以两个数字求和时，它们的“精度损失”会叠加起来，因此0.1+0.2！==0.3；



###### 8、toFixed和Math.round的区别？

（1）定义和用法，都是对数字进行四舍五入操作；Math.round()方法，可把一个数字舍入为最接近的整数；toFixed()方法，可把Number四舍五入为指定小数位数的数字；

（2）返回值的类型不同；Math.round()方法，返回值为数字，toFixed()方法，返回值为字符串。

（3）处理精度不同；Math.round()方法，就一个参数，而且用法也说明了，只返回整数；toFixed()方法，可接受第二个参数，用来规定小数位数；



###### 9、什么是CSP？

CSP指的是内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容；



###### 10、什么是点击劫持？

点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe覆盖在一个网页上。然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面，通过调整iframe页面的位置，可以使用户恰好点击在iframe页面的一些功能性按钮上；



##### 2023.04.06

###### 1、symbol类型在使用时需要注意什么？

（1）symbol函数前不能使用new，否则会报错；

（2）symbol函数可以接受一个字符串作为参数，表示对symbol实例的描述，主要是为了在控制台显示，或者转化为字符串，比较容易区分；

（3）symbol作为属性，该属性不能出现for...in,for...of循环中，也不会被Object.keys()，Object.getOwnPropertyNames()，JSON.stringfy()返回；

（4）Obejct.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的symbol值；

（5）symbol.for接受一个字符串作为参数，然后搜索有没有以该参数作为名称symbol值。如果有，就返回这个symbol值，否则就新建并返回一个以该字符串为名称的symbol值；

（6）symbol.keyFor方法返回一个已登记的symbol类型的值的key；



###### 2、reflect对象创建的目的是什么？

将Object属于语言内部的方法放到Reflect上；修改某些Object方法的返回结果，让其变得更合理；让Object操作变成函数行为，reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在reflect对象上找到对应的方法，reflect是一个内置的对象，它提供拦截JS操作的方法，这些方法与处理器对象的方法相同，reflect不是一个函数对象，因此是不可构造的；



###### 3、响应式原理中的观察者模式和发布订阅模式有什么不同？

观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所以依赖症都会收到通知并自动更新，而观察者模式属于行为型模式，行为型模式关注的是对象之间的通讯，观察者模式就是观察者和被观察者之间的通讯；

在发布订阅模式中，称为发布者的消息发送者不会将消息编程为直接发送给称为订阅者的特定接收者。这意味着发布者和订阅者不知道彼此的存在。存在三个组件，称为代理或消息代理或事件总线，它由发布者和订阅者都知道，它过滤所有传入的消息并相应地分发它们。

（1）在观察者模式中，观察者知道表现对象，同时表现对象还保留了观察者的记录，然而，在发布者/订阅者中，发布者和订阅者不需要彼此了解，他们只是在消息队列或代理的帮助下进行通信；

（2）在发布订阅模式中，组件是松散耦合的，而不是观察者模式；

（3）观察者模式主要以同步方式实现，即当某些事件发生时，表现对象调用其所有的观察者的适当方法。发布者/订阅者在大多数情况下是异步方式（使用消息队列）

（4）观察者模式需要在单个应用程序地址空间中实现，另一方面，发布者/订阅者模式更像是跨应用程序模式；



###### 4、JS的for循环在使用时需要注意什么？

（1）在for循环中“初始化表达式”、“循环后增量表达式”都可不写，如果不写就相当于while(1);

（2）对于非Boolean类型的值，会先转换为Boolean类型再判断；for循环后如只有一条语句可以省内大括号，不能在（）后写；



###### 5、网站域名添加www和不加www有什么区别？

如果网站要考虑SEO搜索引擎优化，则建议将不带www的域名301重定向到www域名，这样有利于确保我们的关键词权重不被搜索引擎分散；如果主机不支持301重定向，可以把首页的所有连接采用绝对地址的链接形式也可以很好解决这个问题；



###### 6、原型用于在多个对象实例间共享属性的方法和原理？

在通过Object访问属性时，会按照这个属性的名称开始搜索，搜索开始于对象实例本身，如在该实例上发现了给定的名称，则返回该名称对应的值。如果没找到该属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值；



###### 7、与watchEffect()相比，watch()优点；

（1）懒执行副作用；

（2）更明确是应该由哪个状态触发侦听器里重新执行；

（3）可以访问所侦听状态的前一个值和当前值；



###### 8、什么是可选链？

是一个调用和查询可选属性、方法和下标的过程，可能为null。如果可选性包含值，属性、方法或者下标的调用成功；如果可选项为null，属性、方法或者下标的调用会返回null，多个查询可以链接在一起，如果链中任何一个节点为null，则整个链都会调用失败；

可选链操作符（？.）是一个新的JS API，允许读取位于连接对象深处属性的值，而不必明确验证链中的每个引用是否有效。？.操作符的功能类似于.链式操作符，不同之处在于，在引用为null或undefined的情况下不会引起错误，该表达式短路返回值是undefined，与函数调用一起使用时，如果给定的函数不存在，则返回undefined；



###### 9、Map和WeakMap有什么区别？

（1）Map的键和值使用对象或任何基本类型，WeakMap仅接受对象；

（2）WeakMap不支持对键和值进行迭代，无法获取WeakMap的所有键或值；

（3）WeakMap不会阻止在没有对键的引用时对键进行垃圾收集；Map无限期地维护对键和值的引用，一旦创建了键和值，它们将占用内存，即使没有对它们的引用，也不会被垃圾收集，可能会导致内存泄漏问题；

（4）WeakMap保存对键的弱引用，且无法枚举，因此无法使用keys()、values()、entries()这些方法；



###### 10、谈谈Object.defineProperty和Proxy有什么区别？

（1）Proxy使用上比Object.defineProperty方便；

（2）Proxy代理整个对象，Object.defineProperty只代理对象上的某个属性；

（3）vue中，Proxy在调用时递归，Object.defineProperty在一开始就全部递归，Proxy性能优于Object.defineProperty；

（4）对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到；

（5）数组新增删除修改时，Proxy可以监听到，Object.defineProperty监听不到；

（6）Proxy不兼容IE，Object.defineProperty不兼容IE8及以下；



##### 2023.04.07

###### 1、get和post在缓存方面的区别？

缓存一般只适用于那些不会更新服务端数据的请求，一般get请求都是查找请求，不会对服务器资源数据造成修改。而post请求一般都会对服务器数据造成修改，所以，一般会对get请求进行缓存，很少对post请求进行缓存；



###### 2、什么是rest参数？

ES6引入rest参数（形式为‘...变量名’），用于获取函数的多余参数，rest参数之后不能再有其他参数（即只能是最后一个参数）

（1）rest参数是真正意义上的数组，可以使用数组的任何方法；

（2）对于函数的length属性，不包含rest；

（3）rest参数只能作为最后一个参数，在它之后不存在任何其他的参数，否则会报错；



###### 3、attribute 和 property 的区别是什么?

attribute是我们在html代码中经常看到的键值对，property是attribute对应的DOM节点的对象属性；

（1）对于html的标准属性来说，attribute和property是同步的，是会自动更新的；

（2）但是对于自定义的属性来说，他们并不同步，property会同步不到；

（3）attribute是DOM元素在文档中作为html标签拥有的属性；

（4）property就是DOM元素在JS中作为对象拥有的属性；



###### 4、console.log(Object.assign([1, 2, 3], [4, 5]))最后输出什么？

[ 4, 5, 3]



###### 5、前端需要注意哪些SEO？

合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前， 不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可；



###### 6、undefined和undeclared的区别？

已在作用域中声明但还未赋值的变量，是undefined的。相反，还没有在作用域中声明过的变量，是undefined的。对于undeclared变量的引用，浏览器会报引用错误，但可以使用typeof的安全防范机制来避免报错，因为对于undeclared变量，typeof会返回“undefined”；



###### 7、内部属性[[Class]]是什么？

所有typeof返回值为“object”对象（如数组）都包含一个内部属性[[class]]（都可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过Object.prototype.toString(...)来查看；



###### 8、typeof NaN的结果是什么？

NaN意指"不是一个数字"，NaN是一个“警戒值”（有特殊用途的常规值）用于指出数字类型中的错误情况，即“执行数学运算没有成功”，这是失败否的返回结果，NaN是一个特殊值，它和自身不相等，是唯一一个非自反（即===不成立）的值，而 != 为true；



###### 9、isNaN和Number.isNaN函数的区别？

isNaN：判断传入的参数是否能转换成数字，如果可以转换为数字，返回false，如果不能转换为数字，返回true；

Number.isNaN：判断传入的值是否全等于NaN，如果是NaN，返回true，其他值都返回false；



###### 10、什么是假值对象？

浏览器在某些特定情况下，在常规JS语法基础上自己创建了一下外来值，这些就是“假值对象”。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换布尔值时结果为false最常见的例子document.all，它是一个类数组对象，包含了页面上的所有元素，由DOM（而不是JS引擎）提供给JS程序使用；



##### 2023.04.10

###### 1、立即调用函数表达式（IIFE）有什么特点？

在声明函数后理解执行，常用于将相关功能整合到单个对象或模块中；



###### 2、JS的本地缓存有哪些方式？

（1）利用storage来对数据进行存储（sessionStorage、localStorage）

（2）cookie



###### 3、什么是单点登录？

在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录；



###### 4、axios拦截器分类有哪些？

请求拦截器、响应拦截器；



###### 5、reflect有什么用？

（1）将Object一些明显属于内部的方法定义到reflect对象上，现阶段，某些方法同时在Object和reflect对象上部署，未来的新方法将只部署在reflect对象上，即从reflect对象上可以拿到语言内部的方法；

（2）修改某些Object方法的结果返回，让其变得更合理；

（3）让Object操作都变成函数行为；

（4）reflect对象的方法与proxy对象的方法一一对应，只要是proxy对象的方法，就能在reflect对象上找到对应的方法。这就让proxy对象可以方便地调用对应的reflect方法，完成默认行为，作为修改行为的基础；



###### 6、slice和splice区别？

（1）slice不会改变原数组，splice会改变原数组；

（2）slice返回原数组中的部分元素，splice返回原数组中被删除的元素组成的新数组；

（3）slice用来选择数组中的元素，splice用于在数组中插入或者删除元素；



###### 7、怎么定义vue-router的动态路由？

动态路由通过两个函数实现；router.addRoute()和router.removeRoute();



###### 8、v-bind和v-model的区别？

（1）使用范围：v-bind适用于所有元素，且主要是绑定元素的属性；v-model只能用于表单元素，表单之外的元素使用了毫无意义，且只能绑定元素的值，其他属性还是需要使用v-bind；

（2）使用模式：v-model是MVVM模式（双向），即可以通过改变Model（即data数据）来改变View；也可以通过改变View来改变Model；v-bind是MV模式（单向），即通过控制Model来改变View；



###### 9、哪些非boolean值被强制转换为一个boolean时，它是false?

数字0、空字符串、null、undefined



###### 10、Object.is()作用是什么？

与 ‘===’ 相像



##### 2023.04.11

###### 1、页面之间是怎样传参数的？

（1）URL：把参数值附在url后面传递到其他页面

（2）H5 web stroage：localStorage和sessionStorage

（3）Cookie

（4）Form表单：通过url传参



###### 2、CSS有哪些选择符？

（1）通配选择符（*）：匹配任意元素；

（2）id选择符

（3）类选择符

（4）标签选择符

（5）相邻选择符

（6）子选择符

（7）后代选择符

（8）伪类和伪元素选择符

（9）属性选择符



###### 3、fixed和absolute的区别？

fixed值定位的元素会固定在原来的位置不变，不管如何拖动滚动条，元素都不会改变位置；

而absolute正好相反，拖动滚动条时元素会随着改变位置；



###### 4、box-shadow，rgba分别代表什么？

box-shadow属性为盒子添加阴影；

rgba：前三个值（红绿蓝）的范围为0~255之间的整数或者0%到100%之间的百分数，这些值描述了红绿蓝原色在预期色彩中的量；第四个值：alpha值，制订了色彩的透明度/不透明度，它的范围为0.0~1.0之间，0.5为半透明；



###### 5、什么时候用less? 

项目足够大，有公共的UI组件，组件或者页面上有相似的拼装属性的方法，组件或者样式拼装上存在继承关系，或者有theme需求；



###### 6、给页面添加标题，都有哪些最佳实践？

（1）标题设置要体现网页的主题，通过标题能够容易理解网页的内容；

（2）注意标题的文字长度，过短的标题可能造成无聊，过长的标题可能会影响阅读体验；

（3）网页标题具有可搜索型，要将能够有效描述网页主题的关键词放到网页标题中，让搜素引擎能识别你的网页，提供可搜索率；

（4）尽量避免在标题中使用无意义的字词；

（5）结合网页内容，将网页标题设置的文字长度控制在60-80个字符内；



###### 7、列表标签都有哪些？

有序列表（ol）、无序列表（ul）、自定义列表（dl）



###### 8、什么是HTML头部元素？

HTML<head>元素</head>是所有头部元素的容器；里面的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息等；



###### 9、为什么要设置alt属性？

（1）alt标签是搜索引擎判断图片内容的重要因素；

（2）alt标签的文本内容会在图片无法读取的时候得以显现；



###### 10、title属性应该填写什么内容？

title全局属性包含表示与其所属元素相关的建议信息文本，即指定元素的提示文本；



##### 2023.04.12

###### 1、什么是SVG？

SVG意为可缩放矢量图，是使用XML来描述二维图形和绘图程序的语言，SVG是放大或改变尺寸的情形下其图形质量不会有所损失，是万维网联盟的标准，SVG与诸如DOM（文件对象模型）和XSL（拓展样式表语言）之类的W3C标准是一个整体；



###### 2、如何创建响应式图片？

（1）srcset：img元素的srcset属性用于浏览器根据宽、高和像素来加载相应图片资源；

（2）srcset配合sizes：img元素的sizes属性给浏览器提供一个预估的图片显示宽度；

（3）picture标签：<picture>元素通过包含零或多个<source>元素和一个<img>元素来为不同的显示/设备场景提供图像版本。浏览器会选择最匹配的子<source>元素，如果没匹配，就选择<img>元素的src属性中的URL；

（4）SVG：是矢量图形，缩放不会失真和变形；



###### 3、为什么不能使用JS来实现响应式图片？

（1）需要命令式的实现响应式逻辑

（2）与业务逻辑耦合了



###### 4、button有几种类型？

普通按钮、粘性按钮、单选按钮及复选框；



###### 5、如何禁用表单元素？

（1）禁用一个输入字段，在html里直接写禁用属性[disable]="disabled"，disabled值在指定情况下设置成true就可以了，如果是input框但使用了form表单的formControlName属性，则disabled属性是不起作用的；

（2）在表单验证的地方直接设置，name：[{value: '', disabled: true}]

（3）获取表单字段设置其禁用，this.form.get('name').disable(),但此方法要注意在后面表单再赋值时要使用this.form.getRawValue()方法。



###### 6、一个图片url访问后直接下载怎样实现?

请求的返回头中，用于浏览器解析的重要参数是OSS的API文档里的http返回头，决定用户下载行为的参数。

（1）x-oss-object-type

Normal

（2）x-oss-request-id

598D5ED34F29D01FE2925F41

（3）x-oss-storage-class:

standard

```js
fetch('http://somehost/somefile.zip').then(res => res.blob().then(blob => {
    var a = document.createElement('a');
    var url = window.URL.createObjectURL(blob);
    var filename = 'myfile.zip';
    a.href = url;
    a.download = filename;
    a.click()
    window.URL.revokeObjectURL(url);
}))
```



###### 7、有哪些常用的BOM属性？

window对象、location位置对象、history浏览器历史记录对象、screen屏幕对象、navigator对象；



###### 8、在HTML中DOCTYPE的作用是什么？

触发浏览器的标准模式；



###### 9、严格模式与混杂模式如何区分？

（1）混杂模式下盒子模型的高宽包括padding和border，而W3C标准中设置一个元素的高宽指的是content的高宽；

（2）混杂模式下可以设置行内元素的高度，而标准模式下不生效；

（3）标准模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的；

（4）标准模式下使用margin：0 auto；可以使元素水平居中，但是混杂模式下会失效，混杂模式下需要设置text-align:center;来进行水平居中；

（5）混杂模式下设置图片padding会生效；

（6）混杂模式下Table中的字体属性不能继承上层的设置；

（7）混杂模式下white-space：pre会失效；



###### 10、$router有哪些方法？

（1）this.$router.addroute()：addRoute添加一条新的路由记录作为现有路由的子路由，如果路由有一个name，并且已经有一个与之名字相同的路由，它会先删除之前的路由；

（2）this.$route.addroutes()：动态添加更多的路由规则。参数必须是一个符合routes选项要求的数组；

（3）this.$router.push()：跳转到不同的url，但这个方法会向history栈添加一个记录，点击后会返回到上一个页面；

（4）this.$router.replace()：它的作用类似于router.push，唯一不同的是，在导航时不会向history添加新记录；

（5）this.$router.go(n)：该方法采用一个整数作为参数，表示在历史堆栈中前进或者后退多少步；



##### 2023.04.13

###### 1、

var x=1

​	switch(x++) { 

​				case 0: ++x  

​				case 1: ++x  

​				case 2: ++x 

}

 console.log(x)  输出的值是多少？

输出值为4



###### 2、useCallback和useMemo区别？

useCallBack：返回值是一个缓存的回调函数，参数是需要缓存的函数，依赖项，使用场景父组件更新时，通过props传递给子组件的函数也会重新创建，然后这个时候使用useCallBack就可以缓存函数不使它重新创建；

useMemo：返回值是一个缓存的值，参数需要缓存的值（也可以是个计算然后再返回值的函数），依赖项，使用场景组件更新时，一些计算量很大的值也有可能被重新计算，这个时候就可以使用useMemo直接使用上一次缓存的值；



###### 3、使用浮动会存在哪些问题？

（1）容错性比较糟糕，容易出问题；

（2）需要元素固定尺寸，很难复用；

（3）在低版本IE会有很多问题；



###### 4、合法的URL由哪些组成？

通信协议（scheme）、主机（host）、端口号（port）、路径（path）、查询（query）、信息片段（fragment）；



###### 5、css如何设置文字超出长度用省略号...展示？

单行省略显示：CSS中可以使用text-overflow属性和white-space来实现过长文本省略显示；

多行省略显示：如果需要实现多行省略显示，可以将overflow设置为hidden,white-space设置为normal，并使用max-height属性限制容器的高度；



###### 6、如何为表格增加标题？

（1）通过fieldset添加标题框；

（2）通过caption添加标题；



###### 7、表格结构标签有哪些，为什么要使用？

结构标签：

thead：定义表格头部（标题行），必须拥有tr标签，一般位于第一行；

tbody：定义表格的主体，通常包含标题行下方的表格数据区域；

（thead和tbody只是用来划分表格结构的，区分标题行和数据区域，不能替代原有的tr、th、td标签的使用）



###### 8、如何定义表格的列标题和行标题？

行标题：<tr>

列标题：<col>



###### 9、常用的表格标签有哪些？

table：表格标签，用于包含多个tr；

tr：定义表格中的行，用于包含多个td；

td：定义表格中的单元格，用于存放单元格内容；

th：定义表头中的单元格，用于存放单元格内容，默认会加粗并居中显示；

thead：定义表格头部（标题行），必须拥有tr标签；

tbody：定义表格的主体，通常包含标题行下方的表格数据区域；



###### 10、为什么要使用CSS而不是’table‘表格布局？

（1）把格式数据混入内容中；

Table使得文件的大小无谓地变大，而用户访问每个页面时都必须下载一次这样的格式信息；

客户的时间和带宽也是有限的；

（2）Table使得重新涉及现有的站点和内容极为消耗劳力，且昂贵；

（3）Table使得保持整个站点的视觉的一致性极难，花费高；

（4）Table页面大大降低了用手机或PDA浏览者的亲和力；

CSS：

（1）使页面载入得更快，降低流量费用；

（2）在修改设计时更有效率且代价更低；

（3）帮助整个站点保持视觉的一致性更容易；

（4）让站点可以更好地被搜索引擎找到；

（5）使站点对浏览者和浏览器更具亲和力；



##### 2023.04.14

###### 1、JS中取整方法？

1. Math.trunc()：去除数字的小数部分，保留整数部分；
2. Math.round()：返回一个数字四舍五入的整数部分；
3. Math.ceil()：实现向上取整；
4. Math.floor()：返回一个小于或等于数字的最小整数，即向下取整；



###### 2、什么是类、抽象类、接口？

类：现实事物都具备属性和行为，类的成员变量对应现实事物的属性，类的成员方法对应现实事物的行为；

抽象类：有抽象方法的类（抽象方法：只有方法声明，没有方法主题的方法，可以定义为抽象方法。abstract修饰的方法叫做抽象方法）

接口：是功能的集合，也是一种数据类型，比抽象类型更为抽象的“类”；



###### 3、获取表单元素的事件？

表单事件

提交事件：

- 表单.onsubmit()表单提交触发事件
- 表单.submit()提交表单函数功能

重置事件

- 表单.onreset()表单重置触发事件
- 表单.reset()重置表单函数功能

焦点事件

- 控件.onfocus表单得到焦点触发事件

失焦事件（onblur）

- 控件.onblur表单得到焦点触发事件

改变事件

- 控件.onchange
- 输入框的改变事件需要失焦后触发

oninput事件：

- input独有事件，改变内容就会触发

select表单事件

添加

- innerHTML为select条件option
- document.createElement()/createTextNode()/？.appendChild()添加
- 独有函数方法：let ？ = new Option('内容'， ’value‘)；表单.add(?)



###### 4、常见的兼容性问题；

CSS兼容：

1. 不同浏览器的标签默认margin和padding不同
2. 在CSS3新属性，加浏览器的前缀兼容早期浏览器
3. 块属性标签float后，又有横行的margin情况下，IE浏览器margin加倍的问题
4. 设置较小高度标签（一般小于10px），在IE6、IE7页面中高度超出自己设置的高度
5. 行内属性标签，设置display：block后采用float布局，又有横行的margin情况，IE6间距bug
6. IE浏览器div最小宽度和高度不生效的问题
7. 超链接访问过后hover样式就不出现的问题
8. 图片默认有间距
9. CSS hack解决浏览器

JS兼容

1. 时间绑定
2. event事件对象问题
3. event.srcElement(事件源对象)问题
4. 获取元素的菲行间样式值
5. 阻止事件冒泡传播
6. 阻止事件默认行为
7. ajax兼容问题



###### 5、解构赋值

```js
let a - 1;
let b = 2;
```

如何在不声明第三个变量的前提下，使a = 2, b = 1？

[a, b] = [b, a]



###### 6、渐进增强、优雅降级的区别是什么？

如果采用渐进增强的开发流程，先做一个基本功能，然后针对各个浏览器进行渐进增加，增加各种功能。相对于优雅降级来说，开发周期长，初期投入资金大，好处就是提供了较好的平台稳定性，维护起来资金小，长期来说降低开发成本；



###### 7、Vue中patch方法的理解？

初始化和更新都是靠patch来完成，patch函数主要接收oldvnode和vnode两个参数，即新旧两棵虚拟树；



###### 8、props为什么要设置默认值？

- 父组件请求数据---同时创建子组件
- 由于数据请求缓慢，子组件先初始化，这个时候props都是没数据的，如果props有对象但没有默认值，在模板上使用就会报错
- 父组件请求数据回来了，修改了data，由于父组件修改data，传进去的props也更新了，从而子组件的props更新，重新render页面



###### 9、Vue中provide/inject的作用是什么？

provide()：提供一个值，可以被后代组件注入

inject()：注入一个由祖先组件或整个应用提供的值



###### 10、为什么在跳转页面路由不能同时使用param和query？

- 通过params属性传值，该方法在跳转页面刷新时数据会丢失
- 通过query属性传值，该方法页面刷新时数据不会丢失，但是会拼接在URL后面，不够安全，一般只传一个参数用于跳转页面掉接口
