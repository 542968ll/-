###### 20、最远足迹

![image-20230516011014864](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011014864.png)

![image-20230516011137104](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011137104.png)

![image-20230516011154176](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011154176.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  console.log(getMaxFar(line));
});
 
function getMaxFar(str) {
  let stack = [];
  let maxFar = 0;
 
  let res;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "(" || stack[0] === "(") {
      stack.push(str[i]);
      if (str[i] === ")") {
        stack.shift();
        stack.pop();
        let [x, y] = stack.join("").split(",");
 
        if (x.startsWith("0") || y.startsWith("0")) {
          if (!res) res = "(0,0)";
        } else {
          let far = x * x + y * y;
          if (far > maxFar) {
            res = `(${x},${y})`;
            maxFar = far;
          }
        }
        stack.length = 0;
      }
    }
  }
 
  return res;
}
```



55、表达式括号匹配

![image-20230516011311286](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011311286.png)

![image-20230516011329648](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011329648.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  const regExp = /[^\(\)]/g;
  line = line.replace(regExp, "");
  let count = 0;
  const stack = [];
  for (let c of line) {
    if (stack.length && c === ")") {
      if (stack.at(-1) === "(") {
        stack.pop();
        count++;
        continue;
      } else {
        return console.log(-1);
      }
    }
    stack.push(c);
  }
  if (stack.length) return console.log(-1);
  return console.log(count);
});
```



###### 56、括号匹配

![image-20230516011438879](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011438879.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  console.log(getResult(line));
});
 
function getResult(line) {
  const regExp = /[^\(\)\[\]\{\}]/g;
 
  // 去除非括号字符
  line = line.replace(regExp, "");
 
  const map = {
    ")": "(",
    "]": "[",
    "}": "{",
  };
 
  const stack = [];
 
  for (let c of line) {
    if (stack.length && map[c]) {
      if (stack.at(-1) === map[c]) {
        stack.pop();
        continue;
      } else {
        return false;
      }
    }
 
    stack.push(c);
  }
  return stack.length == 0;
}
```



57、最大括号深度

![image-20230516011620007](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011620007.png)

![image-20230516011644156](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011644156.png)

![image-20230516011658294](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011658294.png)

![image-20230516011712391](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011712391.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  console.log(getMaxDepth(line));
});
 
function getMaxDepth(str) {
  const map = {
    ")": "(",
    "]": "[",
    "}": "{",
  };
 
  const stack = [str[0]];
 
  let maxDepth = 0;
  let depth = 0;
  for (let i = 1; i < str.length; i++) {
    let c = str[i];
 
    if (map[c] === stack.at(-1)) {
      stack.pop();
      depth++;
      maxDepth = Math.max(maxDepth, depth);
    } else {
      depth = 0;
      stack.push(c);
    }
  }
 
  if (stack.length) return 0;
  return maxDepth;
}
```



###### 58、消消乐游戏

![image-20230516011830454](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011830454.png)

![image-20230516011843474](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011843474.png)

![image-20230516011858185](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516011858185.png)

```js

/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  console.log(xiaoxiaole(line));
});
 
function xiaoxiaole(str) {
  if (/[^a-zA-Z]/.test(str)) return 0;
 
  let stack = [];
  [...str].forEach((ele) => {
    if (stack.length === 0) {
      stack.push(ele);
    } else {
      let peek = stack[stack.length - 1];
      ele === peek ? stack.pop() : stack.push(ele);
    }
  });
  return stack.length;
}
```



15、【200】简单的解压缩算法

![image-20230516012028241](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012028241.png)

![image-20230516012042207](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012042207.png)

![image-20230516012127475](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012127475.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  console.log(getResult(line));
});
 
function getResult(str) {
  const stack = [];
  const idxs = [];
  const repeat = [];
 
  str += " ";
 
  for (let c of str) {
    if (/\d/.test(c)) {
      repeat.push(c);
      continue;
    }
 
    // 如果出现A13,或者{ABC}99这种情况，我们需要把多位数解析出来
    if (repeat.length > 0) {
      const n = parseInt(repeat.join(""));
      repeat.length = 0;
      const top = stack.pop();
      if (top === "}") {
        const frag = stack.splice(idxs.pop()).slice(1).join("");
        stack.push(...new Array(n).fill(frag).join(""));
      } else {
        stack.push(...new Array(n).fill(top));
      }
    }
 
    if (c === "{") {
      idxs.push(stack.length);
    }
 
    stack.push(c);
  }
 
  return stack.join("").trim();
}
```



20、【200】分奖金

![image-20230516012309545](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012309545.png)

![image-20230516012325693](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012325693.png)

```js

/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
const lines = [];
rl.on("line", (line) => {
  lines.push(line);
 
  if (lines.length === 2) {
    const m = lines[0] - 0;
    const arr = lines[1].split(" ").map(Number);
    console.log(getResult(arr, m));
    lines.length = 0;
  }
});
 
function getResult(arr, m) {
  const ans = [];
 
  outter: for (let i = 0; i < m; i++) {
    for (let j = i + 1; j < m; j++) {
      if (arr[j] > arr[i]) {
        ans.push((j-i) * (arr[j] - arr[i])); // 距离 * 数字差值
        continue outter;
      }
    }
    ans.push(arr[i]);
  }
 
  return ans.join(" ");
}
```



###### 21、最大的数字

![image-20230516012501573](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012501573.png)

![image-20230516012531899](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012531899.png)

![image-20230516012549749](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012549749.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  console.log(getResult(line));
});
 
function getResult(str) {
  // 每个数字字符的可用个数
  const unused = {};
  // 每个数字字符的保留个数
  const reserve = {};
 
  // 初始时，每个数字有多少个，就可用多少个，由于还未使用，因此保留个数为0
  for (let c of str) {
    unused[c] ? unused[c]++ : (unused[c] = 1);
    reserve[c] = 0;
  }
 
  // 定义一个栈
  const stack = [];
 
  // 遍历输入字符串的每个数字字符c
  for (let c of str) {
    // 如果该字符已经保留了2个了，则后续再出现该数字字符可以不保留
    if (reserve[c] == 2) {
      // 则可用c数字个数--
      unused[c]--;
      continue;
    }
 
    // 比较当前数字c和栈顶数字top，如果c>top，那么需要考虑将栈顶数字弹出
    while (stack.length) {
      const top = stack.at(-1);
 
      // 如果栈顶数字被弹出后，已保留的top字符数量和未使用的top字符数量之和大于等于2，则可以弹出，否则不可以
      if (top < c && unused[top] + reserve[top] - 1 >= 2) {
        stack.pop();
        reserve[top]--;
      } else {
        break;
      }
    }
 
    // 选择保留当前遍历的数字c
    stack.push(c);
    // 则可用c数字个数--
    unused[c]--;
    // 已保留c数字个数++
    reserve[c]++;
  }
 
  return stack.join("");
}
```



###### 69、信号发射和接收

【留】





###### 110、找朋友

![image-20230516012942119](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516012942119.png)

![image-20230516013005335](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013005335.png)

```js

/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
const lines = [];
rl.on("line", (line) => {
  lines.push(line);
 
  if (lines.length === 2) {
    let n = lines[0];
    let arr = lines[1]
      .split(" ")
      .slice(0, n)
      .map((ele) => parseInt(ele));
 
    console.log(getHigherIndex(arr).join(" "));
 
    lines.length = 0;
  }
});
 
/* 记录第一眼看到比自己高的的人的序号 */
function getHigherIndex(arr) {
  let stack = [];
 
  let len = arr.length;
  let res = new Array(len).fill(0);
 
  for (let i = 0; i < len; i++) {
    let ele = arr[i];
    let index = i;
 
    while (true) {
      if (stack.length === 0) {
        stack.push([ele, index]);
        break;
      }
 
      let [peekEle, peekIndex] = stack[stack.length - 1];
 
      if (ele > peekEle) {
        res[peekIndex] = index;
        stack.pop();
      } else {
        stack.push([ele, index]);
        break;
      }
    }
  }
 
  return res;
}
```



###### 9、【200】报文解压缩

![image-20230516013155124](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013155124.png)

![image-20230516013216374](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013216374.png)

![image-20230516013229140](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013229140.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  console.log(getResult(line));
});
 
/* 算法逻辑 */
function getResult(str) {
  const stack = [];
 
  // idxs记录要被重复的子串的起始位置
  const idxs = [];
  // nums记录要被重复的子串的重复次数，和idxs对应
  const nums = [];
 
  // tmpRepeatCount记录正在拼接的重复次数字符串
  const tmpRepeatCount = [];
 
  // 遍历输入的字符串, c是当前正在遍历的字符
  for (let c of str) {
    if (c == "[") {
      // 此时tmpRepeatCount已记录完当前重复子串对应的重复次数的所有字符
      const repeatCount = Number(tmpRepeatCount.join(""));
      nums.push(repeatCount);
      tmpRepeatCount.length = 0;
 
      // 记录要被重复的子串的起始位置
      idxs.push(stack.length);
    } else if (c == "]") {
      // 需要被重复的子串在栈中的起始位置
      const start = idxs.pop();
      // 需要被重复的次数
      const repeatCount = nums.pop();
      // 需要被重复的子串
      const repeatStr = stack.splice(start).join("");
 
      // 将新串压入栈中
      stack.push(new Array(repeatCount).fill(repeatStr).join(""));
    } else if (c >= "0" && c <= "9") {
      tmpRepeatCount.push(c);
    } else {
      stack.push(c);
    }
  }
 
  return stack.join("");
}
```



###### 16、【200】九宫键按键输入

![image-20230516013347350](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013347350.png)

![image-20230516013403035](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013403035.png)

![image-20230516013425180](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013425180.png)

![image-20230516013440065](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013440065.png)

```js

/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  const arr = [...line];
 
  console.log(getResult(arr));
});
 
function getResult(arr) {
  const map = [
    " ",
    ",.",
    "abc",
    "def",
    "ghi",
    "jkl",
    "mno",
    "pqrs",
    "tuv",
    "wxyz",
  ];
 
  const stack = [];
 
  let mode = true; // true为数字模式，false为英文模式
 
  arr.forEach((char) => {
    switch (char) {
      case "#":
        mode = !mode;
        break;
      case "/":
        if (!mode) ipt(mode, stack, map);
        break;
      default:
        ipt(mode, stack, map, char);
    }
  });
 
  ipt(mode, stack, map);
 
  return stack.join("");
}
 
function ipt(mode, stack, map, char) {
  const top = stack[stack.length - 1];
 
  if (Array.isArray(top)) {
    if (!mode && top[0] == char) {
      return top[1]++;
    } else {
      const [num, count] = stack.pop();
 
      const arr = map[num];
      const len = arr.length;
 
      stack.push(arr[(count - 1) % len]);
    }
  }
 
  if (char) {
    if (mode) {
      stack.push(char);
    } else {
      stack.push([char, 1]);
    }
  }
}
```



###### 18、【200】仿LISP运算

![image-20230516013619425](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013619425.png)

![image-20230516013639684](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013639684.png)

![image-20230516013652982](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013652982.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  const arr = [...line];
 
  console.log(lisp(arr));
});
 
function lisp(arr) {
  const stack = [];
  const opers = [];
 
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === ")") {
      const fragment = stack.splice(opers.pop());
      fragment.shift(); // 把截取出来的片段的头部"("去掉
 
      const [op, p1, p2] = fragment.join("").split(" ");
 
      const res = operate(op, p1 - 0, p2 - 0);
 
      if (res === "error") return "error";
      stack.push(...String(res));
    } else {
	  if (arr[i] === "(") opers.push(stack.length)
      stack.push(arr[i]);
    }
  }
 
  return stack.join("");
}
 
function operate(op, p1, p2) {
  switch (op) {
    case "add":
      return p1 + p2;
    case "sub":
      return p1 - p2;
    case "mul":
      return p1 * p2;
    case "div":
      return p2 === 0 ? "error" : Math.floor(p1 / p2);
  }
}
```



###### 22、【200】斗地主之狮子

![image-20230516013813181](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013813181.png)

![image-20230516013840152](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013840152.png)

![image-20230516013858975](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516013858975.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  const arr = line.split(" ");
  getShunzi(arr);
});
 
function getShunzi(arr) {
  const cards = {
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    10: 10,
    J: 11,
    Q: 12,
    K: 13,
    A: 14,
    2: 16,
  };
 
  arr.sort((a, b) => cards[a] - cards[b]);
 
  let stack = [];
  let res = [];
 
  while (arr.length > 0) {
    let bot = arr.shift();
 
    if (stack.length !== 0) {
      let top = stack[stack.length - 1];
      if (cards[bot] - cards[top] === 1) {
        stack.push(bot);
      } else if (cards[bot] === cards[top]) {
        arr.push(bot);
      } else {
        arr.unshift(bot);
        if (stack.length >= 5) {
          if (stack.length < 10) {
            res.push(stack.join(" "));
          } else {
            res.push(stack.slice(0, 5).join(" "));
            res.push(stack.slice(5).join(" "));
          }
        }
        stack.length = 0;
      }
    } else {
      stack.push(bot);
    }
  }
 
  if (stack.length >= 5) res.push(stack.join(" "));
 
  if (res.length === 0) {
    console.log("No");
  } else {
    res.forEach((str) => console.log(str));
  }
}
```



###### 31、【200】找最小数

![image-20230516014049664](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516014049664.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
const lines = [];
rl.on("line", (line) => {
  lines.push(line);
 
  if (lines.length === 2) {
    const arr = lines[0].split("").map((ele) => parseInt(ele));
    const removeCount = lines[1];
 
    console.log(getMinValue(arr, removeCount));
  }
});
 
function getMinValue(arr, removeCount) {
  if (arr.length === removeCount) return "0";
 
  let remainCount = arr.length - removeCount;
 
  let stack = [];
  for (let i = 0; i < arr.length; i++) {
    while (
      stack.length > 0 &&
      removeCount > 0 &&
      stack[stack.length - 1] > arr[i]
    ) {
      stack.pop();
      removeCount--;
    }
    stack.push(arr[i]);
  }
 
  while (stack.length > remainCount) {
    stack.pop();
  }
 
  while (stack[0] === 0 && stack.length !== 1) {
    stack.shift();
  }
 
  return stack.join("");
}
```



###### 41、【200】最长的完全交替连续方波信号

###### ![image-20230516014234451](C:\Users\GG-BOND\AppData\Roaming\Typora\typora-user-images\image-20230516014234451.png)

![image-20230516014258355](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516014258355.png)

![image-20230516014317215](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516014317215.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  const arr = [...line];
  console.log(getMaxConstantSignal(arr));
});
 
function getMaxConstantSignal(arr) {
  const stack = [];
  const signals = [];
 
  let flag = false;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] == 1) {
      flag = true;
    } else {
      if (stack[stack.length - 1] == 0) {
        if (flag) {
          signals.push(stack.join(""));
          stack.length = 0;
          flag = false;
        } else {
          stack.shift();
        }
      }
    }
    stack.push(arr[i]);
  }
 
  signals.push(stack.join(""));
 
  const regExp = /^0(10)+$/;
  const res = signals.filter((signal) => regExp.test(signal));
 
  if (res.length === 0) return -1;
  else return res.sort((a, b) => a.length - b.length).pop();
}
```



###### 56、【200】二叉树中序遍历

![image-20230516014515206](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516014515206.png)

![image-20230516014539657](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516014539657.png)

![image-20230516014604164](C:\Users\GG-BOND\Desktop\od\单调栈\image-20230516014604164.png)

```js
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");
 
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});
 
rl.on("line", (line) => {
  console.log(getResult(line));
});
 
function getResult(str) {
  const idxs = [];
  const stack = [];
  for (let i = 0; i < str.length; i++) {
    const c = str[i];
 
    if (c == "}") {
      const idx = idxs.pop(); // 左括号索引
      const root = stack[idx - 1]; // 根
      const [left, right] = stack.splice(idx).slice(1).join("").split(",");
      stack.pop();
      stack.push((left ?? "") + root + (right ?? ""));
      continue;
    }
 
    if (c == "{") {
      idxs.push(stack.length);
    }
 
    stack.push(c);
  }
 
  return stack[0];
}
```

